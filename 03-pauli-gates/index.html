<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pauli Gates - Quantum Gates Learning</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        .prereq-box { background: linear-gradient(135deg, rgba(100,255,218,0.1), rgba(78,205,196,0.05)); border: 2px solid rgba(100,255,218,0.3); border-radius: 16px; padding: 25px; margin: 20px 0; }
        .prereq-box h3 { color: #64ffda; margin-bottom: 15px; }
        .prereq-item { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; margin: 12px 0; border-left: 4px solid #64ffda; }
        .prereq-item h4 { color: #4ecdc4; margin-bottom: 8px; }
        .bloch-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0; }
        .bloch-panel { background: rgba(100,255,218,0.05); border: 1px solid rgba(100,255,218,0.2); border-radius: 12px; padding: 15px; }
        .bloch-panel h4 { color: #64ffda; text-align: center; margin-bottom: 10px; }
        .bloch-canvas { width: 100%; height: 280px; border-radius: 8px; background: #050505; }
        .state-indicator { display: flex; align-items: center; justify-content: center; gap: 15px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 8px; margin-top: 10px; font-family: monospace; }
        .matrix-calc { background: rgba(100,255,218,0.08); border-radius: 12px; padding: 20px; margin: 15px 0; }
        .matrix-calc h4 { color: #64ffda; margin-bottom: 15px; }
        .calc-row { display: flex; align-items: center; justify-content: center; gap: 12px; margin: 12px 0; flex-wrap: wrap; }
        .matrix-box { display: inline-grid; grid-template-columns: repeat(2, 40px); gap: 2px; background: rgba(0,0,0,0.4); padding: 8px; border-radius: 6px; border: 1px solid rgba(100,255,218,0.3); }
        .matrix-box .cell { width: 40px; height: 32px; display: flex; align-items: center; justify-content: center; background: rgba(100,255,218,0.15); color: #fff; font-size: 14px; border-radius: 3px; }
        .vector-box { display: inline-grid; grid-template-columns: 40px; gap: 2px; background: rgba(0,0,0,0.4); padding: 8px; border-radius: 6px; border: 1px solid rgba(255,107,107,0.3); }
        .vector-box .cell { width: 40px; height: 32px; display: flex; align-items: center; justify-content: center; background: rgba(255,107,107,0.2); color: #ff6b6b; font-size: 14px; border-radius: 3px; }
        .result-box { border-color: rgba(78,205,196,0.3); }
        .result-box .cell { background: rgba(78,205,196,0.2); color: #4ecdc4; }
        .op-symbol { font-size: 24px; color: #64ffda; font-weight: bold; }
        .calc-detail { background: rgba(0,0,0,0.3); border-radius: 6px; padding: 12px; margin-top: 12px; font-size: 13px; color: #888; text-align: center; }
        .transform-flow { display: flex; align-items: center; justify-content: center; gap: 20px; padding: 20px; flex-wrap: wrap; }
        .state-circle { width: 80px; height: 80px; border-radius: 50%; background: radial-gradient(circle at 30% 30%, rgba(100,255,218,0.4), rgba(0,0,0,0.6)); border: 2px solid rgba(100,255,218,0.5); display: flex; align-items: center; justify-content: center; font-size: 20px; color: #fff; font-family: monospace; }
        .gate-arrow { font-size: 24px; color: #64ffda; }
        .gate-label { background: rgba(100,255,218,0.2); padding: 10px 20px; border-radius: 8px; border: 1px solid rgba(100,255,218,0.4); text-align: center; }
        .gate-label .name { font-size: 28px; color: #64ffda; font-weight: bold; }
        .gate-label .desc { font-size: 11px; color: #888; margin-top: 4px; }
        .interactive-section { background: linear-gradient(135deg, rgba(100,255,218,0.08), rgba(78,205,196,0.03)); border: 2px solid rgba(100,255,218,0.3); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .demo-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 20px; }
        .demo-btn { padding: 12px 24px; border: none; border-radius: 8px; font-size: 15px; cursor: pointer; font-weight: bold; transition: all 0.3s; }
        .btn-x { background: linear-gradient(135deg, #ff6b6b, #ff8e8e); color: #fff; }
        .btn-y { background: linear-gradient(135deg, #4ecdc4, #6ee7de); color: #000; }
        .btn-z { background: linear-gradient(135deg, #ffd93d, #ffe66d); color: #000; }
        .btn-h { background: linear-gradient(135deg, #a855f7, #c084fc); color: #fff; }
        .btn-reset { background: linear-gradient(135deg, #666, #888); color: #fff; }
        .demo-btn:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .main-bloch { width: 100%; height: 400px; border-radius: 12px; background: #050505; }
        .state-display { text-align: center; font-size: 24px; color: #64ffda; margin-top: 15px; font-family: monospace; }
        .amp-bars { display: flex; justify-content: center; gap: 40px; margin-top: 20px; }
        .amp-bar { text-align: center; }
        .bar-container { width: 60px; height: 140px; background: rgba(0,0,0,0.4); border-radius: 8px; position: relative; overflow: hidden; border: 1px solid rgba(100,255,218,0.2); }
        .bar-fill { position: absolute; bottom: 0; width: 100%; background: linear-gradient(to top, #64ffda, #4ecdc4); transition: height 0.4s; border-radius: 0 0 8px 8px; }
        .bar-label { margin-top: 8px; color: #fff; font-size: 16px; font-family: monospace; }
        .bar-value { position: absolute; width: 100%; text-align: center; bottom: 5px; color: #000; font-weight: bold; font-size: 12px; }
        .decision-guide { background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 12px; padding: 20px; margin: 20px 0; }
        .decision-guide h3 { color: #ffd93d; margin-bottom: 15px; }
        .decision-item { display: flex; align-items: flex-start; gap: 15px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; margin: 10px 0; }
        .decision-item .goal { color: #4ecdc4; font-weight: bold; min-width: 200px; }
        .decision-item .solution { color: #fff; }
        .decision-item .gate { color: #ff6b6b; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Pauli Gates</h1>
            <p class="subtitle">X, Y, Z - The Fundamental Quantum Operations</p>
        </header>

        <section class="section">
            <div class="prereq-box">
                <h3>Prerequisites - What You Need to Know First</h3>
                <div class="prereq-item">
                    <h4>1. What is a Qubit?</h4>
                    <p>A qubit can exist in a <strong>superposition</strong> of |0⟩ and |1⟩ states: |ψ⟩ = α|0⟩ + β|1⟩, where |α|² + |β|² = 1. The probabilities of measuring 0 or 1 are |α|² and |β|².</p>
                </div>
                <div class="prereq-item">
                    <h4>2. The Bloch Sphere</h4>
                    <p>A 3D sphere where every point represents a qubit state. <strong>North pole (+Z) = |0⟩</strong>, <strong>South pole (-Z) = |1⟩</strong>, <strong>+X = |+⟩</strong> (equal superposition), <strong>-X = |-⟩</strong>. Gates are rotations on this sphere!</p>
                </div>
                <div class="prereq-item">
                    <h4>3. State Vectors</h4>
                    <p>States are column vectors: |0⟩ = [1, 0]ᵀ and |1⟩ = [0, 1]ᵀ. Gates are 2×2 matrices that transform these vectors through multiplication.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>The Three Pauli Gates - Visual Comparison</h2>
            <p>Each Pauli gate performs a <strong>180° (π) rotation</strong> around its axis. Watch how each transforms the state:</p>
            <div class="bloch-grid">
                <div class="bloch-panel">
                    <h4>X Gate: Rotation around X-axis</h4>
                    <div id="bloch-x" class="bloch-canvas"></div>
                    <div class="state-indicator">
                        <span>|0⟩</span><span style="color:#64ffda">—X→</span><span>|1⟩</span>
                    </div>
                </div>
                <div class="bloch-panel">
                    <h4>Y Gate: Rotation around Y-axis</h4>
                    <div id="bloch-y" class="bloch-canvas"></div>
                    <div class="state-indicator">
                        <span>|0⟩</span><span style="color:#64ffda">—Y→</span><span>i|1⟩</span>
                    </div>
                </div>
                <div class="bloch-panel">
                    <h4>Z Gate: Rotation around Z-axis</h4>
                    <div id="bloch-z" class="bloch-canvas"></div>
                    <div class="state-indicator">
                        <span>|+⟩</span><span style="color:#64ffda">—Z→</span><span>|-⟩</span>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="decision-guide">
                <h3>How to Choose the Right Gate</h3>
                <div class="decision-item">
                    <span class="goal">Flip |0⟩ to |1⟩ (or vice versa):</span>
                    <span class="solution">Use <span class="gate">X gate</span> - it's the quantum NOT gate</span>
                </div>
                <div class="decision-item">
                    <span class="goal">Add phase to |1⟩ component:</span>
                    <span class="solution">Use <span class="gate">Z gate</span> - multiplies |1⟩ by -1</span>
                </div>
                <div class="decision-item">
                    <span class="goal">Flip |+⟩ to |-⟩ (phase in X-basis):</span>
                    <span class="solution">Use <span class="gate">Z gate</span> - it's a phase flip in superposition</span>
                </div>
                <div class="decision-item">
                    <span class="goal">Flip AND add phase:</span>
                    <span class="solution">Use <span class="gate">Y gate</span> - combines X and Z effects</span>
                </div>
                <div class="decision-item">
                    <span class="goal">Create superposition from |0⟩:</span>
                    <span class="solution">Use <span class="gate">H gate</span> (Hadamard) - covered in next module</span>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Pauli-X Gate (Quantum NOT)</h2>
            <div class="gate-card">
                <span class="gate-symbol" style="background:linear-gradient(135deg,#ff6b6b,#ff8e8e);">X</span>
                <h3>Bit Flip - Swaps |0⟩ and |1⟩</h3>
            </div>
            <div class="matrix-calc">
                <h4>Step-by-Step: X|0⟩ = |1⟩</h4>
                <div class="calc-row">
                    <div class="matrix-box"><div class="cell">0</div><div class="cell">1</div><div class="cell">1</div><div class="cell">0</div></div>
                    <span class="op-symbol">×</span>
                    <div class="vector-box"><div class="cell">1</div><div class="cell">0</div></div>
                    <span class="op-symbol">=</span>
                    <div class="vector-box result-box"><div class="cell">0</div><div class="cell">1</div></div>
                    <span style="color:#4ecdc4;font-size:18px;">= |1⟩</span>
                </div>
                <div class="calc-detail">Row 1: (0×1)+(1×0)=0 | Row 2: (1×1)+(0×0)=1</div>
                <div class="transform-flow">
                    <div class="state-circle">|0⟩</div>
                    <span class="gate-arrow">→</span>
                    <div class="gate-label"><div class="name">X</div><div class="desc">180° around X</div></div>
                    <span class="gate-arrow">→</span>
                    <div class="state-circle">|1⟩</div>
                </div>
            </div>
            <div class="matrix-calc">
                <h4>Step-by-Step: X|1⟩ = |0⟩</h4>
                <div class="calc-row">
                    <div class="matrix-box"><div class="cell">0</div><div class="cell">1</div><div class="cell">1</div><div class="cell">0</div></div>
                    <span class="op-symbol">×</span>
                    <div class="vector-box"><div class="cell">0</div><div class="cell">1</div></div>
                    <span class="op-symbol">=</span>
                    <div class="vector-box result-box"><div class="cell">1</div><div class="cell">0</div></div>
                    <span style="color:#4ecdc4;font-size:18px;">= |0⟩</span>
                </div>
                <div class="calc-detail">Row 1: (0×0)+(1×1)=1 | Row 2: (1×0)+(0×1)=0</div>
            </div>
        </section>

        <section class="section">
            <h2>Pauli-Y Gate (Bit + Phase Flip)</h2>
            <div class="gate-card">
                <span class="gate-symbol" style="background:linear-gradient(135deg,#4ecdc4,#6ee7de);">Y</span>
                <h3>Combined Flip - Swaps AND adds phase</h3>
            </div>
            <div class="matrix-calc">
                <h4>Step-by-Step: Y|0⟩ = i|1⟩</h4>
                <div class="calc-row">
                    <div class="matrix-box"><div class="cell">0</div><div class="cell">-i</div><div class="cell">i</div><div class="cell">0</div></div>
                    <span class="op-symbol">×</span>
                    <div class="vector-box"><div class="cell">1</div><div class="cell">0</div></div>
                    <span class="op-symbol">=</span>
                    <div class="vector-box result-box"><div class="cell">0</div><div class="cell">i</div></div>
                    <span style="color:#4ecdc4;font-size:18px;">= i|1⟩</span>
                </div>
                <div class="calc-detail">Row 1: (0×1)+(-i×0)=0 | Row 2: (i×1)+(0×0)=i</div>
            </div>
            <div class="matrix-calc">
                <h4>Step-by-Step: Y|1⟩ = -i|0⟩</h4>
                <div class="calc-row">
                    <div class="matrix-box"><div class="cell">0</div><div class="cell">-i</div><div class="cell">i</div><div class="cell">0</div></div>
                    <span class="op-symbol">×</span>
                    <div class="vector-box"><div class="cell">0</div><div class="cell">1</div></div>
                    <span class="op-symbol">=</span>
                    <div class="vector-box result-box"><div class="cell">-i</div><div class="cell">0</div></div>
                    <span style="color:#4ecdc4;font-size:18px;">= -i|0⟩</span>
                </div>
                <div class="calc-detail">Row 1: (0×0)+(-i×1)=-i | Row 2: (i×0)+(0×1)=0</div>
            </div>
        </section>

        <section class="section">
            <h2>Pauli-Z Gate (Phase Flip)</h2>
            <div class="gate-card">
                <span class="gate-symbol" style="background:linear-gradient(135deg,#ffd93d,#ffe66d);">Z</span>
                <h3>Phase Flip - Adds -1 phase to |1⟩</h3>
            </div>
            <div class="matrix-calc">
                <h4>Step-by-Step: Z|0⟩ = |0⟩ (unchanged!)</h4>
                <div class="calc-row">
                    <div class="matrix-box"><div class="cell">1</div><div class="cell">0</div><div class="cell">0</div><div class="cell">-1</div></div>
                    <span class="op-symbol">×</span>
                    <div class="vector-box"><div class="cell">1</div><div class="cell">0</div></div>
                    <span class="op-symbol">=</span>
                    <div class="vector-box result-box"><div class="cell">1</div><div class="cell">0</div></div>
                    <span style="color:#4ecdc4;font-size:18px;">= |0⟩</span>
                </div>
                <div class="calc-detail">Z has no effect on |0⟩ because there's no |1⟩ component to flip!</div>
            </div>
            <div class="matrix-calc">
                <h4>Step-by-Step: Z|1⟩ = -|1⟩</h4>
                <div class="calc-row">
                    <div class="matrix-box"><div class="cell">1</div><div class="cell">0</div><div class="cell">0</div><div class="cell">-1</div></div>
                    <span class="op-symbol">×</span>
                    <div class="vector-box"><div class="cell">0</div><div class="cell">1</div></div>
                    <span class="op-symbol">=</span>
                    <div class="vector-box result-box"><div class="cell">0</div><div class="cell">-1</div></div>
                    <span style="color:#4ecdc4;font-size:18px;">= -|1⟩</span>
                </div>
                <div class="calc-detail">The |1⟩ component gets multiplied by -1 (phase flip)</div>
            </div>
            <div class="matrix-calc">
                <h4>Key Example: Z|+⟩ = |-⟩ (Phase flip in superposition)</h4>
                <p style="margin-bottom:12px;color:#888;">Where |+⟩ = (|0⟩+|1⟩)/√2</p>
                <div class="calc-row">
                    <div class="matrix-box"><div class="cell">1</div><div class="cell">0</div><div class="cell">0</div><div class="cell">-1</div></div>
                    <span class="op-symbol">×</span>
                    <div class="vector-box"><div class="cell">1/√2</div><div class="cell">1/√2</div></div>
                    <span class="op-symbol">=</span>
                    <div class="vector-box result-box"><div class="cell">1/√2</div><div class="cell">-1/√2</div></div>
                    <span style="color:#4ecdc4;font-size:18px;">= |-⟩</span>
                </div>
                <div class="transform-flow">
                    <div class="state-circle">|+⟩</div>
                    <span class="gate-arrow">→</span>
                    <div class="gate-label"><div class="name">Z</div><div class="desc">180° around Z</div></div>
                    <span class="gate-arrow">→</span>
                    <div class="state-circle">|-⟩</div>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Interactive Bloch Sphere - Try It Yourself!</h2>
            <p>Click buttons to apply gates and watch the state transform. Think about which gate to use before clicking!</p>
            <div class="interactive-section">
                <div class="demo-controls">
                    <button class="demo-btn btn-x" onclick="applyGate('X')">Apply X</button>
                    <button class="demo-btn btn-y" onclick="applyGate('Y')">Apply Y</button>
                    <button class="demo-btn btn-z" onclick="applyGate('Z')">Apply Z</button>
                    <button class="demo-btn btn-h" onclick="applyGate('H')">Apply H</button>
                    <button class="demo-btn btn-reset" onclick="resetState()">Reset to |0⟩</button>
                </div>
                <div id="main-bloch" class="main-bloch"></div>
                <div class="state-display" id="current-state">Current State: |0⟩</div>
                <div class="amp-bars">
                    <div class="amp-bar">
                        <div class="bar-container"><div class="bar-fill" id="bar-0" style="height:100%;"></div><div class="bar-value" id="val-0">1.00</div></div>
                        <div class="bar-label">|0⟩</div>
                    </div>
                    <div class="amp-bar">
                        <div class="bar-container"><div class="bar-fill" id="bar-1" style="height:0%;"></div><div class="bar-value" id="val-1">0.00</div></div>
                        <div class="bar-label">|1⟩</div>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Key Relationships</h2>
            <div class="highlight">
                <h3>Self-Inverse Property</h3>
                <p style="text-align:center;font-size:18px;">X² = Y² = Z² = I (Identity)</p>
                <p style="text-align:center;color:#888;">Applying any Pauli gate twice returns the original state!</p>
            </div>
            <div class="example">
                <h3>Product Relations</h3>
                <p style="text-align:center;">XY = iZ | YZ = iX | ZX = iY</p>
                <p style="text-align:center;color:#888;margin-top:8px;">Y = iXZ (Y combines X and Z effects)</p>
            </div>
        </section>

        <div class="nav-buttons">
            <a href="../02-single-qubit-gates/index.html" class="btn">Previous: Single-Qubit Gates</a>
            <a href="../04-identity-phase-gates/index.html" class="btn btn-primary">Next: Identity & Phase Gates</a>
        </div>
    </div>

    <script>
    function createBloch(id, axis, color) {
        const c = document.getElementById(id);
        if (!c) return;
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        const camera = new THREE.PerspectiveCamera(50, c.clientWidth/c.clientHeight, 0.1, 1000);
        camera.position.set(2, 1.5, 2);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(c.clientWidth, c.clientHeight);
        c.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const light = new THREE.PointLight(0xffffff, 0.8);
        light.position.set(5,5,5);
        scene.add(light);
        scene.add(new THREE.Mesh(new THREE.SphereGeometry(1,32,32), new THREE.MeshPhongMaterial({color:0x64ffda,transparent:true,opacity:0.1})));
        scene.add(new THREE.Mesh(new THREE.SphereGeometry(1,16,16), new THREE.MeshBasicMaterial({color:0x64ffda,wireframe:true,transparent:true,opacity:0.15})));
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1.2, 0xff6b6b, 0.08, 0.04));
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 1.2, 0x4ecdc4, 0.08, 0.04));
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 1.2, 0xffd93d, 0.08, 0.04));
        [{pos:[1.35,0,0],text:'X',color:'#ff6b6b'},{pos:[0,1.35,0],text:'Y',color:'#4ecdc4'},{pos:[0,0,1.35],text:'Z',color:'#ffd93d'}].forEach(l=>{
            const canvas=document.createElement('canvas');canvas.width=32;canvas.height=32;
            const ctx=canvas.getContext('2d');ctx.fillStyle=l.color;ctx.font='bold 20px monospace';ctx.textAlign='center';ctx.fillText(l.text,16,22);
            const sprite=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(canvas),transparent:true}));
            sprite.position.set(l.pos[0],l.pos[1],l.pos[2]);sprite.scale.set(0.3,0.3,1);scene.add(sprite);
        });
        const ring= new THREE.Mesh(new THREE.TorusGeometry(0.9,0.02,16,100), new THREE.MeshBasicMaterial({color:color,transparent:true,opacity:0.6}));
        if(axis==='x') ring.rotation.y = Math.PI/2;
        else if(axis==='y') ring.rotation.x = Math.PI/2;
        scene.add(ring);
        const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 1, 0xffffff, 0.1, 0.06);
        scene.add(arrow);
        const trail = [];
        const trailGeo = new THREE.BufferGeometry();
        scene.add(new THREE.Line(trailGeo, new THREE.LineBasicMaterial({color:color,transparent:true,opacity:0.5})));
        let angle = 0;
        function animate() {
            requestAnimationFrame(animate);
            angle += 0.02;
            let dir = new THREE.Vector3(0,0,1);
            if(axis==='x') dir.applyAxisAngle(new THREE.Vector3(1,0,0), angle);
            else if(axis==='y') dir.applyAxisAngle(new THREE.Vector3(0,1,0), angle);
            else dir.applyAxisAngle(new THREE.Vector3(0,0,1), angle);
            arrow.setDirection(dir.normalize());
            trail.push(dir.clone());
            if(trail.length > 60) trail.shift();
            const pos = new Float32Array(trail.length*3);
            trail.forEach((p,i) => { pos[i*3]=p.x; pos[i*3+1]=p.y; pos[i*3+2]=p.z; });
            trailGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    }
    createBloch('bloch-x', 'x', 0xff6b6b);
    createBloch('bloch-y', 'y', 0x4ecdc4);
    createBloch('bloch-z', 'z', 0xffd93d);

    const mainC = document.getElementById('main-bloch');
    const mainScene = new THREE.Scene();
    mainScene.background = new THREE.Color(0x050505);
    const mainCam = new THREE.PerspectiveCamera(50, mainC.clientWidth/mainC.clientHeight, 0.1, 1000);
    mainCam.position.set(2.5, 2, 2.5);
    const mainRend = new THREE.WebGLRenderer({antialias:true});
    mainRend.setSize(mainC.clientWidth, mainC.clientHeight);
    mainC.appendChild(mainRend.domElement);
    const mainCtrl = new THREE.OrbitControls(mainCam, mainRend.domElement);
    mainCtrl.enableDamping = true;
    mainScene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const ml = new THREE.PointLight(0xffffff, 0.8);
    ml.position.set(10,10,10);
    mainScene.add(ml);
    mainScene.add(new THREE.Mesh(new THREE.SphereGeometry(1,32,32), new THREE.MeshPhongMaterial({color:0x64ffda,transparent:true,opacity:0.1})));
    mainScene.add(new THREE.Mesh(new THREE.SphereGeometry(1,16,16), new THREE.MeshBasicMaterial({color:0x64ffda,wireframe:true,transparent:true,opacity:0.15})));
    mainScene.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1.3, 0xff6b6b, 0.1, 0.05));
    mainScene.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 1.3, 0x4ecdc4, 0.1, 0.05));
    mainScene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 1.3, 0xffd93d, 0.1, 0.05));
    [{pos:[1.5,0,0],text:'X',color:'#ff6b6b'},{pos:[0,1.5,0],text:'Y',color:'#4ecdc4'},{pos:[0,0,1.5],text:'Z',color:'#ffd93d'}].forEach(l=>{
        const canvas=document.createElement('canvas');canvas.width=64;canvas.height=32;
        const ctx=canvas.getContext('2d');ctx.fillStyle=l.color;ctx.font='bold 24px monospace';ctx.textAlign='center';ctx.fillText(l.text,32,24);
        const sprite=new THREE.Sprite(new THREE.SpriteMaterial({map:new THREE.CanvasTexture(canvas),transparent:true}));
        sprite.position.set(l.pos[0],l.pos[1],l.pos[2]);sprite.scale.set(0.4,0.2,1);mainScene.add(sprite);
    });
    ['x','y','z'].forEach((a,i) => {
        const colors = [0xff6b6b, 0x4ecdc4, 0xffd93d];
        const r = new THREE.Mesh(new THREE.TorusGeometry(0.85,0.01,16,100), new THREE.MeshBasicMaterial({color:colors[i],transparent:true,opacity:0.2}));
        if(a==='x') r.rotation.y = Math.PI/2;
        else if(a==='y') r.rotation.x = Math.PI/2;
        mainScene.add(r);
    });
    let theta = 0, phi = 0;
    const mainArrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 1, 0xffffff, 0.12, 0.08);
    mainScene.add(mainArrow);
    const mainTrail = [];
    const mainTrailGeo = new THREE.BufferGeometry();
    mainScene.add(new THREE.Line(mainTrailGeo, new THREE.LineBasicMaterial({color:0x64ffda,transparent:true,opacity:0.6})));

    function updateState() {
        const x = Math.sin(theta)*Math.cos(phi), y = Math.sin(theta)*Math.sin(phi), z = Math.cos(theta);
        mainArrow.setDirection(new THREE.Vector3(x,y,z).normalize());
        const a0 = Math.abs(Math.cos(theta/2)), a1 = Math.abs(Math.sin(theta/2));
        document.getElementById('bar-0').style.height = (a0*100)+'%';
        document.getElementById('bar-1').style.height = (a1*100)+'%';
        document.getElementById('val-0').textContent = a0.toFixed(2);
        document.getElementById('val-1').textContent = a1.toFixed(2);
        let s = 'Superposition';
        const e = 0.05;
        if(theta < e) s = '|0⟩';
        else if(Math.abs(theta-Math.PI) < e) s = '|1⟩';
        else if(Math.abs(theta-Math.PI/2) < e) {
            if(Math.abs(phi) < e || Math.abs(phi-2*Math.PI) < e) s = '|+⟩';
            else if(Math.abs(Math.abs(phi)-Math.PI) < e) s = '|-⟩';
        }
        document.getElementById('current-state').textContent = 'Current State: ' + s;
    }

    let anim = false;
    function applyGate(g) {
        if(anim) return;
        mainTrail.length = 0;
        let tt = theta, tp = phi;
        if(g==='X') { tt = Math.PI-theta; tp = -phi; }
        else if(g==='Y') { tt = Math.PI-theta; tp = Math.PI-phi; }
        else if(g==='Z') { tp = phi+Math.PI; }
        else if(g==='H') { tt = Math.PI/2-theta; tp = phi+Math.PI; }
        while(tp > Math.PI) tp -= 2*Math.PI;
        while(tp < -Math.PI) tp += 2*Math.PI;
        anim = true;
        const st = theta, sp = phi, steps = 40;
        let step = 0;
        function doStep() {
            step++;
            const t = step/steps, ease = t<0.5 ? 2*t*t : 1-Math.pow(-2*t+2,2)/2;
            theta = st + (tt-st)*ease;
            phi = sp + (tp-sp)*ease;
            const x = Math.sin(theta)*Math.cos(phi), y = Math.sin(theta)*Math.sin(phi), z = Math.cos(theta);
            mainTrail.push(new THREE.Vector3(x,y,z));
            updateState();
            if(mainTrail.length > 1) {
                const pos = new Float32Array(mainTrail.length*3);
                mainTrail.forEach((p,i) => { pos[i*3]=p.x; pos[i*3+1]=p.y; pos[i*3+2]=p.z; });
                mainTrailGeo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
            }
            if(step < steps) requestAnimationFrame(doStep);
            else { theta = tt; phi = tp; updateState(); anim = false; }
        }
        doStep();
    }

    function resetState() {
        if(anim) return;
        theta = 0; phi = 0;
        mainTrail.length = 0;
        mainTrailGeo.setAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
        updateState();
    }

    function mainAnim() {
        requestAnimationFrame(mainAnim);
        mainCtrl.update();
        mainRend.render(mainScene, mainCam);
    }
    mainAnim();
    updateState();

    window.addEventListener('resize', () => {
        mainCam.aspect = mainC.clientWidth/mainC.clientHeight;
        mainCam.updateProjectionMatrix();
        mainRend.setSize(mainC.clientWidth, mainC.clientHeight);
    });
    </script>
</body>
</html>
