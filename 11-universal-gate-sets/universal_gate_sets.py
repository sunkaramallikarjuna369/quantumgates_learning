"""
Universal Gate Sets - Interactive Python Demonstrations
======================================================

This script demonstrates universal gate sets:
- Common universal sets
- Gate approximation
- Solovay-Kitaev concept
- Clifford vs Universal

Requirements: numpy, matplotlib
Install: pip install numpy matplotlib
"""

import numpy as np
import matplotlib.pyplot as plt
import warnings
warnings.filterwarnings('ignore')

# Basic gates
I = np.eye(2, dtype=complex)
X = np.array([[0, 1], [1, 0]], dtype=complex)
Y = np.array([[0, -1j], [1j, 0]], dtype=complex)
Z = np.array([[1, 0], [0, -1]], dtype=complex)
H = np.array([[1, 1], [1, -1]], dtype=complex) / np.sqrt(2)
S = np.array([[1, 0], [0, 1j]], dtype=complex)
T = np.array([[1, 0], [0, np.exp(1j * np.pi / 4)]], dtype=complex)

# Two-qubit gates
CNOT = np.array([
    [1, 0, 0, 0],
    [0, 1, 0, 0],
    [0, 0, 0, 1],
    [0, 0, 1, 0]
], dtype=complex)


def Rx(theta):
    """Rotation around X-axis."""
    return np.array([
        [np.cos(theta/2), -1j*np.sin(theta/2)],
        [-1j*np.sin(theta/2), np.cos(theta/2)]
    ], dtype=complex)


def Ry(theta):
    """Rotation around Y-axis."""
    return np.array([
        [np.cos(theta/2), -np.sin(theta/2)],
        [np.sin(theta/2), np.cos(theta/2)]
    ], dtype=complex)


def Rz(theta):
    """Rotation around Z-axis."""
    return np.array([
        [np.exp(-1j*theta/2), 0],
        [0, np.exp(1j*theta/2)]
    ], dtype=complex)


def is_unitary(matrix, tol=1e-10):
    """Check if a matrix is unitary."""
    n = matrix.shape[0]
    product = np.dot(matrix.conj().T, matrix)
    return np.allclose(product, np.eye(n), atol=tol)


def gate_distance(U, V):
    """Compute distance between two unitaries (operator norm)."""
    return np.linalg.norm(U - V, ord=2)


def demo_clifford_gates():
    """Demonstrate Clifford gates."""
    print("=" * 60)
    print("CLIFFORD GATES")
    print("=" * 60)
    
    print("\nThe Clifford group is generated by: H, S, CNOT")
    print("Clifford gates map Pauli operators to Pauli operators.")
    
    print("\n--- Hadamard transforms Paulis ---")
    paulis = [('X', X), ('Y', Y), ('Z', Z)]
    for name, P in paulis:
        transformed = np.dot(H, np.dot(P, H.conj().T))
        # Find which Pauli it maps to
        for name2, P2 in paulis:
            if np.allclose(transformed, P2) or np.allclose(transformed, -P2):
                sign = '+' if np.allclose(transformed, P2) else '-'
                print(f"  H·{name}·H† = {sign}{name2}")
                break
    
    print("\n--- S transforms Paulis ---")
    for name, P in paulis:
        transformed = np.dot(S, np.dot(P, S.conj().T))
        for name2, P2 in paulis:
            if np.allclose(transformed, P2) or np.allclose(transformed, -P2):
                sign = '+' if np.allclose(transformed, P2) else '-'
                print(f"  S·{name}·S† = {sign}{name2}")
                break
            elif np.allclose(transformed, 1j*P2) or np.allclose(transformed, -1j*P2):
                sign = '+i' if np.allclose(transformed, 1j*P2) else '-i'
                print(f"  S·{name}·S† = {sign}{name2}")
                break


def demo_t_gate_importance():
    """Demonstrate why T gate is special."""
    print("\n" + "=" * 60)
    print("THE T GATE: KEY TO UNIVERSALITY")
    print("=" * 60)
    
    print("\nT = diag(1, e^(iπ/4)) - a π/8 rotation around Z")
    print(f"\nT gate matrix:\n{np.round(T, 4)}")
    
    print("\n--- T is NOT a Clifford gate ---")
    print("T does NOT map Paulis to Paulis (up to phase):")
    
    transformed = np.dot(T, np.dot(X, T.conj().T))
    print(f"\nT·X·T† =\n{np.round(transformed, 4)}")
    print("This is NOT a Pauli matrix!")
    
    print("\n--- T enables universality ---")
    print("Clifford gates alone can be efficiently simulated classically.")
    print("Adding T makes the gate set universal and enables quantum advantage.")


def demo_approximation():
    """Demonstrate gate approximation."""
    print("\n" + "=" * 60)
    print("GATE APPROXIMATION")
    print("=" * 60)
    
    print("\nAny single-qubit gate can be approximated using H, S, T.")
    
    # Target: Rx(π/7) - an arbitrary rotation
    target = Rx(np.pi / 7)
    print(f"\nTarget gate: Rx(π/7)")
    print(f"Target matrix:\n{np.round(target, 4)}")
    
    # Try some approximations using H, S, T sequences
    approximations = [
        ('H', H),
        ('T', T),
        ('H·T', np.dot(H, T)),
        ('T·H', np.dot(T, H)),
        ('H·T·H', np.dot(H, np.dot(T, H))),
        ('T·H·T', np.dot(T, np.dot(H, T))),
        ('H·T·H·T', np.dot(H, np.dot(T, np.dot(H, T)))),
        ('T·H·T·H', np.dot(T, np.dot(H, np.dot(T, H)))),
    ]
    
    print("\n--- Approximation attempts ---")
    for name, approx in approximations:
        dist = gate_distance(target, approx)
        print(f"{name:15s}: distance = {dist:.4f}")
    
    print("\nNote: Better approximations require longer sequences.")
    print("Solovay-Kitaev algorithm finds optimal sequences efficiently.")


def demo_universal_sets():
    """Demonstrate different universal gate sets."""
    print("\n" + "=" * 60)
    print("COMMON UNIVERSAL GATE SETS")
    print("=" * 60)
    
    sets = [
        ("Clifford + T", ["H", "S", "CNOT", "T"]),
        ("CNOT + Rotations", ["CNOT", "Rx(θ)", "Ry(θ)", "Rz(θ)"]),
        ("Toffoli + H", ["Toffoli", "H"]),
        ("√SWAP + Single-qubit", ["√SWAP", "Any single-qubit"]),
        ("CZ + Single-qubit", ["CZ", "Any single-qubit"]),
    ]
    
    for name, gates in sets:
        print(f"\n{name}:")
        print(f"  Gates: {', '.join(gates)}")


def demo_solovay_kitaev_concept():
    """Explain Solovay-Kitaev theorem concept."""
    print("\n" + "=" * 60)
    print("SOLOVAY-KITAEV THEOREM")
    print("=" * 60)
    
    print("""
The Solovay-Kitaev theorem states:

  Any single-qubit gate can be approximated to precision ε
  using O(log^c(1/ε)) gates from a universal set.

Where c ≈ 2 (can be improved to ~1.44 with better algorithms).

This is remarkable because:
1. The number of gates grows only POLYLOGARITHMICALLY with precision
2. We can achieve arbitrary precision with finite resources
3. The algorithm is constructive - it tells us HOW to find the sequence
    """)
    
    print("\n--- Example gate counts for different precisions ---")
    precisions = [0.1, 0.01, 0.001, 0.0001, 0.00001]
    for eps in precisions:
        # Approximate gate count (rough estimate)
        gates = int(10 * np.log(1/eps)**2)
        print(f"  ε = {eps:.5f}: ~{gates} gates")


def plot_gate_set_comparison():
    """Visualize different universal gate sets."""
    fig, ax = plt.subplots(figsize=(12, 6))
    fig.patch.set_facecolor('#1a1a2e')
    ax.set_facecolor('#0a0a0a')
    
    sets = [
        ("Clifford + T", 4, '#64ffda'),
        ("CNOT + Rotations", 4, '#ff6b6b'),
        ("Toffoli + H", 2, '#ffd93d'),
        ("CZ + Rotations", 4, '#a78bfa'),
    ]
    
    x = np.arange(len(sets))
    names = [s[0] for s in sets]
    counts = [s[1] for s in sets]
    colors = [s[2] for s in sets]
    
    bars = ax.bar(x, counts, color=colors, edgecolor='white', linewidth=2)
    
    ax.set_xticks(x)
    ax.set_xticklabels(names, color='white', fontsize=10)
    ax.set_ylabel('Number of Gate Types', color='white')
    ax.set_title('Universal Gate Sets Comparison', 
                fontsize=14, fontweight='bold', color='#64ffda')
    ax.tick_params(colors='white')
    
    # Add gate names on bars
    gate_labels = [
        "H, S, CNOT, T",
        "CNOT, Rx, Ry, Rz",
        "Toffoli, H",
        "CZ, Rx, Ry, Rz",
    ]
    for bar, label in zip(bars, gate_labels):
        ax.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.1,
               label, ha='center', va='bottom', color='white', fontsize=8)
    
    ax.set_ylim(0, 6)
    
    plt.tight_layout()
    plt.savefig('universal_gate_sets.png', dpi=150, bbox_inches='tight', facecolor='#1a1a2e')
    print("\nSaved: universal_gate_sets.png")
    plt.show()


def plot_approximation_convergence():
    """Visualize how approximation improves with more gates."""
    fig, ax = plt.subplots(figsize=(10, 6))
    fig.patch.set_facecolor('#1a1a2e')
    ax.set_facecolor('#0a0a0a')
    
    # Simulate approximation improvement
    # (In reality, this would use Solovay-Kitaev algorithm)
    np.random.seed(42)
    n_gates = np.arange(1, 51)
    
    # Theoretical bound: error ~ 1/n^2 (simplified)
    errors = 1.0 / (n_gates ** 0.8) + 0.01 * np.random.randn(len(n_gates))
    errors = np.maximum(errors, 0.001)
    
    ax.semilogy(n_gates, errors, 'o-', color='#64ffda', linewidth=2, markersize=4)
    ax.axhline(y=0.01, color='#ff6b6b', linestyle='--', label='1% error threshold')
    ax.axhline(y=0.001, color='#ffd93d', linestyle='--', label='0.1% error threshold')
    
    ax.set_xlabel('Number of Gates', color='white')
    ax.set_ylabel('Approximation Error', color='white')
    ax.set_title('Gate Approximation Convergence', 
                fontsize=14, fontweight='bold', color='#64ffda')
    ax.tick_params(colors='white')
    ax.legend()
    ax.grid(True, alpha=0.2)
    
    plt.tight_layout()
    plt.savefig('approximation_convergence.png', dpi=150, bbox_inches='tight', facecolor='#1a1a2e')
    print("Saved: approximation_convergence.png")
    plt.show()


def main():
    """Main function."""
    print("\n" + "=" * 60)
    print("UNIVERSAL GATE SETS")
    print("Building Any Quantum Operation from Simple Gates")
    print("=" * 60)
    
    demo_clifford_gates()
    demo_t_gate_importance()
    demo_approximation()
    demo_universal_sets()
    demo_solovay_kitaev_concept()
    
    print("\n" + "=" * 60)
    print("GENERATING VISUALIZATIONS")
    print("=" * 60)
    
    plot_gate_set_comparison()
    plot_approximation_convergence()
    
    print("\n" + "=" * 60)
    print("KEY TAKEAWAYS")
    print("=" * 60)
    print("""
1. Universal gate sets can approximate ANY unitary
2. Common sets: {H,S,CNOT,T}, {CNOT,Rx,Ry,Rz}, {Toffoli,H}
3. Clifford gates alone are NOT universal (classically simulable)
4. T gate provides the "magic" for universality
5. Solovay-Kitaev: O(log²(1/ε)) gates for precision ε
6. Physical quantum computers implement universal sets
7. Gate synthesis is a key compilation step
8. Different sets have different physical implementations
    """)


if __name__ == "__main__":
    main()
