<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single-Qubit Gates - Quantum Gates Learning</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Single-Qubit Gates</h1>
            <p class="subtitle">Rotations on the Bloch Sphere</p>
        </header>

        <section class="section">
            <h2>Overview</h2>
            <p>
                Single-qubit gates act on a two-dimensional complex vector space C². Any single-qubit 
                unitary can be represented as a <strong>rotation on the Bloch Sphere</strong>.
            </p>
            
            <div id="canvas-container"></div>
        </section>

        <section class="section">
            <h2>General Form</h2>
            <p>Every single-qubit gate U can be expressed as:</p>
            
            <div class="formula">
                U(θ, φ, λ) = 
                <br><br>
                [ cos(θ/2)          -e^(iλ) sin(θ/2)  ]
                <br>
                [ e^(iφ) sin(θ/2)    e^(i(φ+λ)) cos(θ/2) ]
            </div>
            
            <p>
                This describes a general rotation by angle θ about an axis defined by φ and λ.
            </p>
            
            <div class="key-point">
                <h3>Parameters</h3>
                <ul>
                    <li><strong>θ (theta):</strong> Rotation angle (0 to π)</li>
                    <li><strong>φ (phi):</strong> Azimuthal angle of rotation axis</li>
                    <li><strong>λ (lambda):</strong> Phase parameter</li>
                </ul>
            </div>
        </section>

        <section class="section">
            <h2>Interactive Gate Explorer</h2>
            <div class="controls">
                <div class="control-group">
                    <label>θ (Theta): <span id="theta-value">π/2</span></label>
                    <input type="range" id="theta-slider" min="0" max="314" value="157">
                </div>
                <div class="control-group">
                    <label>φ (Phi): <span id="phi-value">0</span></label>
                    <input type="range" id="phi-slider" min="0" max="628" value="0">
                </div>
                <div class="control-group">
                    <label>λ (Lambda): <span id="lambda-value">0</span></label>
                    <input type="range" id="lambda-slider" min="0" max="628" value="0">
                </div>
                <div class="control-group">
                    <button id="reset-btn">Reset</button>
                    <button id="apply-x">Apply X</button>
                    <button id="apply-h">Apply H</button>
                    <button id="apply-z">Apply Z</button>
                </div>
            </div>
            
            <div id="gate-canvas"></div>
        </section>

        <section class="section">
            <h2>Special Cases</h2>
            <div class="concept-grid">
                <div class="gate-card">
                    <span class="gate-symbol">X</span>
                    <h3>Pauli-X Gate</h3>
                    <p>θ = π, φ = 0, λ = π</p>
                    <p>Rotation by π about X-axis (bit flip)</p>
                </div>
                <div class="gate-card">
                    <span class="gate-symbol">Y</span>
                    <h3>Pauli-Y Gate</h3>
                    <p>θ = π, φ = π/2, λ = π/2</p>
                    <p>Rotation by π about Y-axis</p>
                </div>
                <div class="gate-card">
                    <span class="gate-symbol">Z</span>
                    <h3>Pauli-Z Gate</h3>
                    <p>θ = 0, φ = 0, λ = π</p>
                    <p>Rotation by π about Z-axis (phase flip)</p>
                </div>
                <div class="gate-card">
                    <span class="gate-symbol">H</span>
                    <h3>Hadamard Gate</h3>
                    <p>θ = π/2, φ = 0, λ = π</p>
                    <p>Rotation about X+Z axis</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Matrix Representation</h2>
            <p>Single-qubit gates are 2×2 unitary matrices:</p>
            
            <div class="example">
                <h3>General Unitary</h3>
                <div class="matrix">
                    <p>U = </p>
                    <div class="matrix-grid matrix-2x2">
                        <div class="matrix-cell">a</div>
                        <div class="matrix-cell">b</div>
                        <div class="matrix-cell">c</div>
                        <div class="matrix-cell">d</div>
                    </div>
                    <p>where |a|² + |c|² = 1, |b|² + |d|² = 1, ab* + cd* = 0</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Bloch Sphere Interpretation</h2>
            <div class="highlight">
                <p>
                    Every single-qubit gate corresponds to a rotation of the Bloch sphere. The rotation 
                    can be characterized by:
                </p>
                <ul>
                    <li><strong>Rotation axis:</strong> A unit vector n = (nx, ny, nz)</li>
                    <li><strong>Rotation angle:</strong> θ radians about the axis</li>
                </ul>
                <p>
                    The gate can be written as: U = exp(-iθ n·σ/2) where σ = (X, Y, Z) are Pauli matrices.
                </p>
            </div>
        </section>

        <div class="nav-buttons">
            <a href="../01-introduction/index.html" class="btn">Previous: Introduction</a>
            <a href="../03-pauli-gates/index.html" class="btn btn-primary">Next: Pauli Gates</a>
        </div>
    </div>

    <script>
        // Main visualization
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(2.5, 2, 2.5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);
        
        // Bloch sphere
        const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
        const sphereMaterial = new THREE.MeshPhongMaterial({
            color: 0x64ffda,
            transparent: true,
            opacity: 0.15
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);
        
        const wireframeGeometry = new THREE.SphereGeometry(1, 16, 16);
        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0x64ffda,
            wireframe: true,
            transparent: true,
            opacity: 0.2
        });
        scene.add(new THREE.Mesh(wireframeGeometry, wireframeMaterial));
        
        // Axes
        const axisLength = 1.3;
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), axisLength, 0xff6b6b, 0.1, 0.05));
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), axisLength, 0x4ecdc4, 0.1, 0.05));
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), axisLength, 0xffd93d, 0.1, 0.05));
        
        // State vector
        let stateTheta = 0;
        let statePhi = 0;
        const stateVector = new THREE.ArrowHelper(
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(0, 0, 0),
            1, 0xff6b6b, 0.15, 0.1
        );
        scene.add(stateVector);
        
        // Rotation visualization
        const rotationRing = new THREE.Mesh(
            new THREE.TorusGeometry(0.5, 0.02, 16, 100),
            new THREE.MeshBasicMaterial({ color: 0xffd93d, transparent: true, opacity: 0.6 })
        );
        scene.add(rotationRing);
        
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Animate state vector
            const theta = Math.PI / 4 + Math.sin(time * 0.5) * Math.PI / 6;
            const phi = time;
            
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(theta);
            
            stateVector.setDirection(new THREE.Vector3(x, y, z).normalize());
            
            rotationRing.rotation.x = Math.PI / 2;
            rotationRing.rotation.z = time * 0.5;
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
        
        // Slider controls
        const thetaSlider = document.getElementById('theta-slider');
        const phiSlider = document.getElementById('phi-slider');
        const lambdaSlider = document.getElementById('lambda-slider');
        
        thetaSlider.addEventListener('input', (e) => {
            const val = (e.target.value / 100).toFixed(2);
            document.getElementById('theta-value').textContent = `${val}π`;
        });
        
        phiSlider.addEventListener('input', (e) => {
            const val = (e.target.value / 100).toFixed(2);
            document.getElementById('phi-value').textContent = `${val}π`;
        });
        
        lambdaSlider.addEventListener('input', (e) => {
            const val = (e.target.value / 100).toFixed(2);
            document.getElementById('lambda-value').textContent = `${val}π`;
        });
        
        document.getElementById('reset-btn').addEventListener('click', () => {
            thetaSlider.value = 157;
            phiSlider.value = 0;
            lambdaSlider.value = 0;
        });
    </script>
</body>
</html>
