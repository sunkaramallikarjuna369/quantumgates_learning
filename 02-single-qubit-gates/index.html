<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Single-Qubit Gates - Devin's Teaching Style</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        .fourwh-box { background: linear-gradient(135deg, rgba(100,255,218,0.12), rgba(78,205,196,0.06)); border: 2px solid rgba(100,255,218,0.4); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .fourwh-box h3 { color: #64ffda; margin-bottom: 20px; font-size: 1.4em; }
        .fourwh-item { background: rgba(0,0,0,0.4); border-radius: 12px; padding: 20px; margin: 15px 0; border-left: 5px solid; }
        .fourwh-item.what { border-color: #ff6b6b; }
        .fourwh-item.why { border-color: #ffd93d; }
        .fourwh-item.when { border-color: #4ecdc4; }
        .fourwh-item.where { border-color: #a855f7; }
        .fourwh-item.how { border-color: #64ffda; }
        .fourwh-item h4 { margin-bottom: 12px; font-size: 1.2em; }
        .fourwh-item.what h4 { color: #ff6b6b; }
        .fourwh-item.why h4 { color: #ffd93d; }
        .fourwh-item.when h4 { color: #4ecdc4; }
        .fourwh-item.where h4 { color: #a855f7; }
        .fourwh-item.how h4 { color: #64ffda; }
        .fourwh-item p, .fourwh-item li { color: #ccc; line-height: 1.7; }
        .prereq-box { background: linear-gradient(135deg, rgba(168,85,247,0.1), rgba(168,85,247,0.05)); border: 2px solid rgba(168,85,247,0.3); border-radius: 16px; padding: 25px; margin: 20px 0; }
        .prereq-box h3 { color: #a855f7; margin-bottom: 15px; }
        .prereq-item { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; margin: 12px 0; border-left: 4px solid #a855f7; }
        .prereq-item h4 { color: #c084fc; margin-bottom: 8px; }
        .bloch-container { display: flex; gap: 30px; justify-content: center; flex-wrap: wrap; margin: 20px 0; }
        .bloch-main { background: rgba(0,0,0,0.5); border-radius: 16px; padding: 20px; }
        .bloch-canvas { width: 450px; height: 450px; border-radius: 12px; background: #050505; }
        .angle-display { background: rgba(0,0,0,0.6); border-radius: 12px; padding: 20px; min-width: 280px; }
        .angle-display h4 { color: #64ffda; margin-bottom: 15px; text-align: center; }
        .angle-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; margin: 8px 0; background: rgba(100,255,218,0.1); border-radius: 8px; }
        .angle-name { font-weight: bold; }
        .angle-name.theta { color: #ff6b6b; }
        .angle-name.phi { color: #4ecdc4; }
        .angle-value { font-family: monospace; font-size: 1.1em; color: #fff; }
        .angle-bar { width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; margin-top: 8px; overflow: hidden; }
        .angle-bar-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }
        .angle-bar-fill.theta { background: linear-gradient(90deg, #ff6b6b, #ff8e8e); }
        .angle-bar-fill.phi { background: linear-gradient(90deg, #4ecdc4, #6ee7de); }
        .state-info { text-align: center; margin-top: 15px; padding: 15px; background: rgba(100,255,218,0.1); border-radius: 8px; }
        .state-info .state { font-size: 1.3em; color: #64ffda; font-family: monospace; }
        .state-info .coords { color: #888; font-size: 0.9em; margin-top: 8px; }
        .matrix-derivation { background: rgba(255,215,0,0.08); border: 2px solid rgba(255,215,0,0.3); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .matrix-derivation h3 { color: #ffd93d; margin-bottom: 20px; }
        .derivation-step { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 20px; margin: 15px 0; }
        .derivation-step h4 { color: #4ecdc4; margin-bottom: 12px; }
        .derivation-step .explanation { color: #ccc; line-height: 1.6; }
        .derivation-step .formula { background: rgba(100,255,218,0.1); padding: 15px; border-radius: 8px; margin: 10px 0; font-family: monospace; font-size: 1.1em; color: #64ffda; text-align: center; }
        .matrix-visual { display: flex; align-items: center; justify-content: center; gap: 15px; margin: 20px 0; flex-wrap: wrap; }
        .matrix-box { display: inline-grid; grid-template-columns: repeat(2, 50px); gap: 4px; background: rgba(0,0,0,0.5); padding: 12px; border-radius: 10px; border: 2px solid rgba(100,255,218,0.3); }
        .matrix-box .cell { width: 50px; height: 40px; display: flex; align-items: center; justify-content: center; background: rgba(100,255,218,0.15); color: #fff; font-size: 14px; border-radius: 5px; font-family: monospace; }
        .vector-box { display: inline-grid; grid-template-columns: 50px; gap: 4px; background: rgba(0,0,0,0.5); padding: 12px; border-radius: 10px; border: 2px solid rgba(255,107,107,0.3); }
        .vector-box .cell { width: 50px; height: 40px; display: flex; align-items: center; justify-content: center; background: rgba(255,107,107,0.2); color: #ff6b6b; font-size: 14px; border-radius: 5px; font-family: monospace; }
        .result-box { border-color: rgba(78,205,196,0.3); }
        .result-box .cell { background: rgba(78,205,196,0.2); color: #4ecdc4; }
        .op-symbol { font-size: 28px; color: #64ffda; font-weight: bold; }
        .interactive-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 20px 0; }
        .ctrl-btn { padding: 12px 24px; border: none; border-radius: 10px; font-size: 15px; cursor: pointer; font-weight: bold; transition: all 0.3s; }
        .ctrl-btn:hover { transform: scale(1.05); box-shadow: 0 4px 20px rgba(0,0,0,0.4); }
        .btn-x { background: linear-gradient(135deg, #ff6b6b, #ff8e8e); color: #fff; }
        .btn-y { background: linear-gradient(135deg, #4ecdc4, #6ee7de); color: #000; }
        .btn-z { background: linear-gradient(135deg, #ffd93d, #ffe66d); color: #000; }
        .btn-h { background: linear-gradient(135deg, #a855f7, #c084fc); color: #fff; }
        .btn-s { background: linear-gradient(135deg, #f472b6, #f9a8d4); color: #000; }
        .btn-t { background: linear-gradient(135deg, #38bdf8, #7dd3fc); color: #000; }
        .btn-reset { background: linear-gradient(135deg, #666, #888); color: #fff; }
        .gate-card { background: rgba(0,0,0,0.4); border-radius: 16px; padding: 25px; margin: 25px 0; border: 2px solid; }
        .gate-card.x-gate { border-color: rgba(255,107,107,0.5); }
        .gate-card.y-gate { border-color: rgba(78,205,196,0.5); }
        .gate-card.z-gate { border-color: rgba(255,217,61,0.5); }
        .gate-card.h-gate { border-color: rgba(168,85,247,0.5); }
        .gate-card.s-gate { border-color: rgba(244,114,182,0.5); }
        .gate-card.t-gate { border-color: rgba(56,189,248,0.5); }
        .gate-card h3 { margin-bottom: 20px; }
        .gate-card.x-gate h3 { color: #ff6b6b; }
        .gate-card.y-gate h3 { color: #4ecdc4; }
        .gate-card.z-gate h3 { color: #ffd93d; }
        .gate-card.h-gate h3 { color: #a855f7; }
        .gate-card.s-gate h3 { color: #f472b6; }
        .gate-card.t-gate h3 { color: #38bdf8; }
        .gate-section { display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin: 15px 0; }
        @media (max-width: 768px) { .gate-section { grid-template-columns: 1fr; } }
        .gate-left { }
        .gate-right { background: rgba(0,0,0,0.3); border-radius: 12px; padding: 20px; }
        .mini-bloch { width: 100%; height: 250px; border-radius: 12px; background: #050505; }
        .key-insight { background: linear-gradient(135deg, rgba(255,107,107,0.1), rgba(255,107,107,0.05)); border: 2px solid rgba(255,107,107,0.3); border-radius: 12px; padding: 20px; margin: 20px 0; }
        .key-insight h4 { color: #ff6b6b; margin-bottom: 10px; }
        .key-insight p { color: #ccc; line-height: 1.6; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Single-Qubit Gates</h1>
            <p class="subtitle">Devin's Teaching Style - Every Gate Explained from First Principles</p>
        </header>

        <section class="section">
            <div class="prereq-box">
                <h3>Prerequisites - What You Must Know First</h3>
                <div class="prereq-item">
                    <h4>1. Qubit State as a Vector</h4>
                    <p>A qubit state |ψ⟩ = α|0⟩ + β|1⟩ is written as a column vector [α, β]ᵀ. The numbers α and β are complex probability amplitudes. When measured, probability of |0⟩ is |α|² and |1⟩ is |β|².</p>
                </div>
                <div class="prereq-item">
                    <h4>2. The Bloch Sphere</h4>
                    <p>Every single-qubit state maps to a point on the Bloch sphere. |0⟩ is at the north pole (+Z), |1⟩ at the south pole (-Z). Superposition states like |+⟩ and |-⟩ are on the equator.</p>
                </div>
                <div class="prereq-item">
                    <h4>3. Gates as Rotations</h4>
                    <p>Single-qubit gates are rotations on the Bloch sphere. The X gate rotates 180° around X-axis, Y gate around Y-axis, Z gate around Z-axis. Understanding this makes gates intuitive!</p>
                </div>
                <div class="prereq-item">
                    <h4>4. Unitary Matrices</h4>
                    <p>All quantum gates are unitary: U†U = I. This means gates preserve probability (|α|² + |β|² = 1) and are reversible (you can always undo a gate by applying its inverse).</p>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="fourwh-box">
                <h3>Single-Qubit Gates - The 4W+H Framework</h3>
                
                <div class="fourwh-item what">
                    <h4>WHAT are Single-Qubit Gates?</h4>
                    <p>Single-qubit gates are 2×2 unitary matrices that transform one qubit's state. They are the quantum equivalent of classical logic gates like NOT. Each gate performs a specific rotation on the Bloch sphere, changing the qubit's state in a predictable way.</p>
                </div>
                
                <div class="fourwh-item why">
                    <h4>WHY do we need different gates?</h4>
                    <p>Different gates serve different purposes:</p>
                    <ul style="margin:10px 0 0 20px;">
                        <li><strong>X gate:</strong> Flips the qubit (like classical NOT)</li>
                        <li><strong>H gate:</strong> Creates superposition (no classical equivalent!)</li>
                        <li><strong>Z, S, T gates:</strong> Add phases (crucial for quantum interference)</li>
                        <li><strong>Y gate:</strong> Combines flip and phase</li>
                    </ul>
                </div>
                
                <div class="fourwh-item when">
                    <h4>WHEN to use each gate?</h4>
                    <p><strong>X:</strong> Initialize |1⟩ from |0⟩, flip qubits in algorithms. <strong>H:</strong> Start of most algorithms to create superposition. <strong>Z:</strong> Phase kickback in oracles. <strong>S, T:</strong> Fine-grained phase control, T-gates for fault-tolerant computing.</p>
                </div>
                
                <div class="fourwh-item where">
                    <h4>WHERE in quantum circuits?</h4>
                    <p>Single-qubit gates appear throughout circuits. H gates often start circuits (creating superposition). X gates prepare initial states. Z, S, T gates appear in the middle for phase manipulation. Gates can be combined: HZH = X, showing deep connections.</p>
                </div>
                
                <div class="fourwh-item how">
                    <h4>HOW do they work mathematically?</h4>
                    <p>Apply gate U to state |ψ⟩ = [α, β]ᵀ by matrix multiplication: U|ψ⟩. On the Bloch sphere, this is a rotation. The rotation axis and angle are determined by the gate's matrix structure. We'll derive each gate's matrix below!</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Interactive Gate Explorer with θ/φ Visualization</h2>
            <p>Apply gates and watch how θ (theta) and φ (phi) change in real-time:</p>
            
            <div class="bloch-container">
                <div class="bloch-main">
                    <div id="bloch-container" class="bloch-canvas"></div>
                    <div class="interactive-controls">
                        <button class="ctrl-btn btn-x" onclick="applyGate('X')">X Gate</button>
                        <button class="ctrl-btn btn-y" onclick="applyGate('Y')">Y Gate</button>
                        <button class="ctrl-btn btn-z" onclick="applyGate('Z')">Z Gate</button>
                        <button class="ctrl-btn btn-h" onclick="applyGate('H')">H Gate</button>
                        <button class="ctrl-btn btn-s" onclick="applyGate('S')">S Gate</button>
                        <button class="ctrl-btn btn-t" onclick="applyGate('T')">T Gate</button>
                        <button class="ctrl-btn btn-reset" onclick="resetState()">Reset</button>
                    </div>
                </div>
                <div class="angle-display">
                    <h4>Current Angles (Real-Time)</h4>
                    <div class="angle-item">
                        <span class="angle-name theta">θ (Theta)</span>
                        <span class="angle-value" id="theta-value">0°</span>
                    </div>
                    <div class="angle-bar"><div class="angle-bar-fill theta" id="theta-bar" style="width:0%;"></div></div>
                    <p style="color:#888;font-size:0.85em;margin-top:5px;">Polar angle from +Z (0° to 180°)</p>
                    
                    <div class="angle-item" style="margin-top:20px;">
                        <span class="angle-name phi">φ (Phi)</span>
                        <span class="angle-value" id="phi-value">0°</span>
                    </div>
                    <div class="angle-bar"><div class="angle-bar-fill phi" id="phi-bar" style="width:0%;"></div></div>
                    <p style="color:#888;font-size:0.85em;margin-top:5px;">Azimuthal angle in XY plane (0° to 360°)</p>
                    
                    <div class="state-info">
                        <div class="state" id="current-state">|0⟩</div>
                        <div class="coords" id="current-coords">x=0, y=0, z=1</div>
                    </div>
                    
                    <div style="margin-top:15px;padding:15px;background:rgba(255,215,0,0.1);border-radius:8px;">
                        <p style="color:#ffd93d;font-size:0.9em;margin:0;"><strong>Gate History:</strong></p>
                        <p style="color:#888;font-size:0.85em;margin:5px 0 0 0;" id="gate-history">None</p>
                    </div>
                </div>
            </div>
        </section>

        <div class="gate-card x-gate">
            <h3>X Gate (Pauli-X / Quantum NOT)</h3>
            <div class="fourwh-box" style="margin-top:0;">
                <div class="fourwh-item what">
                    <h4>WHAT does X do?</h4>
                    <p>The X gate swaps |0⟩ and |1⟩. It's the quantum equivalent of the classical NOT gate. On the Bloch sphere, it's a 180° rotation around the X-axis.</p>
                </div>
                <div class="fourwh-item why">
                    <h4>WHY is the matrix [[0,1],[1,0]]?</h4>
                    <p>We need X|0⟩ = |1⟩ and X|1⟩ = |0⟩. In matrix form: first column = output for |0⟩ = [0,1]ᵀ, second column = output for |1⟩ = [1,0]ᵀ. This gives us [[0,1],[1,0]].</p>
                </div>
                <div class="fourwh-item how">
                    <h4>HOW does it transform states?</h4>
                    <div class="matrix-visual">
                        <div class="matrix-box">
                            <div class="cell">0</div><div class="cell">1</div>
                            <div class="cell">1</div><div class="cell">0</div>
                        </div>
                        <span class="op-symbol">×</span>
                        <div class="vector-box">
                            <div class="cell">α</div><div class="cell">β</div>
                        </div>
                        <span class="op-symbol">=</span>
                        <div class="vector-box result-box">
                            <div class="cell">β</div><div class="cell">α</div>
                        </div>
                    </div>
                    <p style="color:#888;text-align:center;margin-top:10px;">The amplitudes swap! α|0⟩ + β|1⟩ becomes β|0⟩ + α|1⟩</p>
                </div>
            </div>
        </div>

        <div class="gate-card z-gate">
            <h3>Z Gate (Pauli-Z / Phase Flip)</h3>
            <div class="fourwh-box" style="margin-top:0;">
                <div class="fourwh-item what">
                    <h4>WHAT does Z do?</h4>
                    <p>The Z gate adds a phase of -1 (or 180°) to the |1⟩ component. It leaves |0⟩ unchanged but flips the sign of |1⟩. On the Bloch sphere, it's a 180° rotation around the Z-axis.</p>
                </div>
                <div class="fourwh-item why">
                    <h4>WHY is the matrix [[1,0],[0,-1]]?</h4>
                    <p>We need Z|0⟩ = |0⟩ (unchanged) and Z|1⟩ = -|1⟩ (phase flip). First column = [1,0]ᵀ, second column = [0,-1]ᵀ. This gives [[1,0],[0,-1]].</p>
                </div>
                <div class="fourwh-item how">
                    <h4>HOW does it transform states?</h4>
                    <div class="matrix-visual">
                        <div class="matrix-box">
                            <div class="cell">1</div><div class="cell">0</div>
                            <div class="cell">0</div><div class="cell">-1</div>
                        </div>
                        <span class="op-symbol">×</span>
                        <div class="vector-box">
                            <div class="cell">α</div><div class="cell">β</div>
                        </div>
                        <span class="op-symbol">=</span>
                        <div class="vector-box result-box">
                            <div class="cell">α</div><div class="cell">-β</div>
                        </div>
                    </div>
                    <p style="color:#888;text-align:center;margin-top:10px;">Only β changes sign! α|0⟩ + β|1⟩ becomes α|0⟩ - β|1⟩</p>
                </div>
            </div>
            <div class="key-insight">
                <h4>Key Insight: Z doesn't change |0⟩ or |1⟩!</h4>
                <p>If you apply Z to |0⟩, you get |0⟩. If you apply Z to |1⟩, you get -|1⟩, but -|1⟩ and |1⟩ are the same state (global phase doesn't matter). Z only has visible effects on superposition states like |+⟩ → |-⟩.</p>
            </div>
        </div>

        <div class="gate-card y-gate">
            <h3>Y Gate (Pauli-Y)</h3>
            <div class="fourwh-box" style="margin-top:0;">
                <div class="fourwh-item what">
                    <h4>WHAT does Y do?</h4>
                    <p>The Y gate combines a bit flip (like X) with a phase flip (like Z). It's a 180° rotation around the Y-axis. Y = iXZ (up to global phase).</p>
                </div>
                <div class="fourwh-item why">
                    <h4>WHY is the matrix [[0,-i],[i,0]]?</h4>
                    <p>Y|0⟩ = i|1⟩ and Y|1⟩ = -i|0⟩. The factors of i ensure Y is unitary and Y² = I. First column = [0,i]ᵀ, second column = [-i,0]ᵀ.</p>
                </div>
                <div class="fourwh-item how">
                    <h4>HOW does it transform states?</h4>
                    <div class="matrix-visual">
                        <div class="matrix-box">
                            <div class="cell">0</div><div class="cell">-i</div>
                            <div class="cell">i</div><div class="cell">0</div>
                        </div>
                        <span class="op-symbol">×</span>
                        <div class="vector-box">
                            <div class="cell">α</div><div class="cell">β</div>
                        </div>
                        <span class="op-symbol">=</span>
                        <div class="vector-box result-box">
                            <div class="cell">-iβ</div><div class="cell">iα</div>
                        </div>
                    </div>
                    <p style="color:#888;text-align:center;margin-top:10px;">Swaps AND adds phases! α|0⟩ + β|1⟩ becomes -iβ|0⟩ + iα|1⟩</p>
                </div>
            </div>
        </div>

        <div class="gate-card h-gate">
            <h3>H Gate (Hadamard)</h3>
            <div class="fourwh-box" style="margin-top:0;">
                <div class="fourwh-item what">
                    <h4>WHAT does H do?</h4>
                    <p>The Hadamard gate creates superposition! H|0⟩ = |+⟩ = (|0⟩+|1⟩)/√2 and H|1⟩ = |-⟩ = (|0⟩-|1⟩)/√2. It's a 180° rotation around the X+Z axis (diagonal).</p>
                </div>
                <div class="fourwh-item why">
                    <h4>WHY is the matrix (1/√2)[[1,1],[1,-1]]?</h4>
                    <p>We need H|0⟩ = (|0⟩+|1⟩)/√2 = [1/√2, 1/√2]ᵀ and H|1⟩ = (|0⟩-|1⟩)/√2 = [1/√2, -1/√2]ᵀ. These become the columns of H. The 1/√2 factor ensures normalization.</p>
                </div>
                <div class="fourwh-item how">
                    <h4>HOW does it transform states?</h4>
                    <div class="matrix-visual">
                        <div class="matrix-box">
                            <div class="cell">1/√2</div><div class="cell">1/√2</div>
                            <div class="cell">1/√2</div><div class="cell">-1/√2</div>
                        </div>
                        <span class="op-symbol">×</span>
                        <div class="vector-box">
                            <div class="cell">1</div><div class="cell">0</div>
                        </div>
                        <span class="op-symbol">=</span>
                        <div class="vector-box result-box">
                            <div class="cell">1/√2</div><div class="cell">1/√2</div>
                        </div>
                    </div>
                    <p style="color:#888;text-align:center;margin-top:10px;">|0⟩ becomes |+⟩ - equal superposition of |0⟩ and |1⟩!</p>
                </div>
            </div>
            <div class="key-insight">
                <h4>Key Insight: H is its own inverse!</h4>
                <p>Applying H twice returns to the original state: HH = I. This is because H|+⟩ = |0⟩ and H|-⟩ = |1⟩. The Hadamard gate "toggles" between the Z-basis (|0⟩, |1⟩) and X-basis (|+⟩, |-⟩).</p>
            </div>
        </div>

        <div class="gate-card s-gate">
            <h3>S Gate (Phase Gate / √Z)</h3>
            <div class="fourwh-box" style="margin-top:0;">
                <div class="fourwh-item what">
                    <h4>WHAT does S do?</h4>
                    <p>The S gate adds a 90° phase (factor of i) to |1⟩. It's a 90° rotation around the Z-axis. S² = Z, so S is the "square root of Z".</p>
                </div>
                <div class="fourwh-item why">
                    <h4>WHY is the matrix [[1,0],[0,i]]?</h4>
                    <p>We need S|0⟩ = |0⟩ and S|1⟩ = i|1⟩. First column = [1,0]ᵀ, second column = [0,i]ᵀ. The factor i = e^(iπ/2) represents a 90° phase.</p>
                </div>
                <div class="fourwh-item how">
                    <h4>HOW does it transform states?</h4>
                    <div class="matrix-visual">
                        <div class="matrix-box">
                            <div class="cell">1</div><div class="cell">0</div>
                            <div class="cell">0</div><div class="cell">i</div>
                        </div>
                        <span class="op-symbol">×</span>
                        <div class="vector-box">
                            <div class="cell">α</div><div class="cell">β</div>
                        </div>
                        <span class="op-symbol">=</span>
                        <div class="vector-box result-box">
                            <div class="cell">α</div><div class="cell">iβ</div>
                        </div>
                    </div>
                    <p style="color:#888;text-align:center;margin-top:10px;">Only the |1⟩ amplitude gets multiplied by i (90° phase shift)</p>
                </div>
            </div>
        </div>

        <div class="gate-card t-gate">
            <h3>T Gate (π/8 Gate / √S)</h3>
            <div class="fourwh-box" style="margin-top:0;">
                <div class="fourwh-item what">
                    <h4>WHAT does T do?</h4>
                    <p>The T gate adds a 45° phase (factor of e^(iπ/4)) to |1⟩. It's a 45° rotation around the Z-axis. T² = S, T⁴ = Z. The T gate is crucial for universal quantum computing!</p>
                </div>
                <div class="fourwh-item why">
                    <h4>WHY is the matrix [[1,0],[0,e^(iπ/4)]]?</h4>
                    <p>We need T|0⟩ = |0⟩ and T|1⟩ = e^(iπ/4)|1⟩. The phase e^(iπ/4) = (1+i)/√2 represents a 45° rotation. This fine-grained phase control enables universal computation.</p>
                </div>
                <div class="fourwh-item how">
                    <h4>HOW does it transform states?</h4>
                    <div class="matrix-visual">
                        <div class="matrix-box">
                            <div class="cell">1</div><div class="cell">0</div>
                            <div class="cell">0</div><div class="cell">e^iπ/4</div>
                        </div>
                        <span class="op-symbol">×</span>
                        <div class="vector-box">
                            <div class="cell">α</div><div class="cell">β</div>
                        </div>
                        <span class="op-symbol">=</span>
                        <div class="vector-box result-box">
                            <div class="cell">α</div><div class="cell">e^iπ/4·β</div>
                        </div>
                    </div>
                    <p style="color:#888;text-align:center;margin-top:10px;">45° phase added to |1⟩ component only</p>
                </div>
            </div>
            <div class="key-insight">
                <h4>Key Insight: T gate makes quantum computing universal!</h4>
                <p>The set {H, T, CNOT} is universal - any quantum computation can be approximated using only these gates. The T gate provides the "non-Clifford" element needed for universality. This is why T gates are so important in fault-tolerant quantum computing.</p>
            </div>
        </div>

        <section class="section">
            <div class="matrix-derivation">
                <h3>Summary: Gate Relationships</h3>
                <div class="derivation-step">
                    <h4>Pauli Gates Form a Group</h4>
                    <p class="explanation">X² = Y² = Z² = I (each Pauli gate is its own inverse). Also: XY = iZ, YZ = iX, ZX = iY. The Pauli matrices plus I form a basis for all 2×2 matrices!</p>
                </div>
                <div class="derivation-step">
                    <h4>Phase Gate Hierarchy</h4>
                    <div class="formula">T² = S, S² = Z, Z² = I</div>
                    <p class="explanation">T is the "finest" phase gate (45°), S is coarser (90°), Z is coarsest (180°). You can build Z from S gates, and S from T gates.</p>
                </div>
                <div class="derivation-step">
                    <h4>Hadamard Connections</h4>
                    <div class="formula">HXH = Z, HZH = X, HYH = -Y</div>
                    <p class="explanation">H swaps the X and Z axes! This is why H converts between Z-basis and X-basis measurements.</p>
                </div>
            </div>
        </section>

        <div class="nav-buttons">
            <a href="../01-introduction/index.html" class="btn">Previous: Introduction</a>
            <a href="../03-pauli-gates/index.html" class="btn btn-primary">Next: Pauli Gates Deep Dive</a>
        </div>
    </div>

    <script>
    let scene, camera, renderer, controls, stateArrow;
    let theta = 0, phi = 0;
    let gateHistory = [];
    
    function init() {
        const container = document.getElementById('bloch-container');
        if (!container) return;
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        
        camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(3, 2.5, 3);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
        dirLight.position.set(5, 5, 5);
        scene.add(dirLight);
        
        const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
        const sphereMat = new THREE.MeshPhongMaterial({ color: 0x64ffda, transparent: true, opacity: 0.12 });
        scene.add(new THREE.Mesh(sphereGeo, sphereMat));
        
        const wireGeo = new THREE.SphereGeometry(1, 16, 16);
        const wireMat = new THREE.MeshBasicMaterial({ color: 0x64ffda, wireframe: true, transparent: true, opacity: 0.15 });
        scene.add(new THREE.Mesh(wireGeo, wireMat));
        
        createAxis(new THREE.Vector3(1, 0, 0), 0xff6b6b, '+X', '-X');
        createAxis(new THREE.Vector3(0, 1, 0), 0x4ecdc4, '+Y', '-Y');
        createAxis(new THREE.Vector3(0, 0, 1), 0xffd93d, '+Z |0>', '-Z |1>');
        
        const eqGeo = new THREE.RingGeometry(0.99, 1.01, 64);
        const eqMat = new THREE.MeshBasicMaterial({ color: 0x64ffda, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
        const equator = new THREE.Mesh(eqGeo, eqMat);
        equator.rotation.x = Math.PI / 2;
        scene.add(equator);
        
        stateArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1.1, 0x64ffda, 0.15, 0.1);
        scene.add(stateArrow);
        
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        animate();
        updateDisplay();
    }
    
    function createAxis(dir, color, posLabel, negLabel) {
        scene.add(new THREE.ArrowHelper(dir, new THREE.Vector3(0,0,0), 1.5, color, 0.1, 0.06));
        scene.add(new THREE.ArrowHelper(dir.clone().negate(), new THREE.Vector3(0,0,0), 1.5, color, 0.1, 0.06));
        [0.5, 1.0].forEach(function(d) {
            var g = new THREE.SphereGeometry(0.02, 8, 8);
            var m = new THREE.MeshBasicMaterial({ color: color });
            var t1 = new THREE.Mesh(g, m); t1.position.copy(dir.clone().multiplyScalar(d)); scene.add(t1);
            var t2 = new THREE.Mesh(g, m); t2.position.copy(dir.clone().multiplyScalar(-d)); scene.add(t2);
        });
        createLabel(posLabel, dir.clone().multiplyScalar(1.7), color);
        createLabel(negLabel, dir.clone().multiplyScalar(-1.7), color);
    }
    
    function createLabel(text, pos, color) {
        var c = document.createElement('canvas'); c.width = 128; c.height = 64;
        var ctx = c.getContext('2d');
        ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
        ctx.font = 'bold 24px Arial'; ctx.textAlign = 'center';
        ctx.fillText(text, 64, 40);
        var t = new THREE.CanvasTexture(c);
        var s = new THREE.Sprite(new THREE.SpriteMaterial({ map: t, transparent: true }));
        s.position.copy(pos); s.scale.set(0.5, 0.25, 1); scene.add(s);
    }
    
    function updateDisplay() {
        var td = (theta * 180 / Math.PI).toFixed(1);
        var pd = ((phi * 180 / Math.PI + 360) % 360).toFixed(1);
        document.getElementById('theta-value').textContent = td + '\u00B0';
        document.getElementById('phi-value').textContent = pd + '\u00B0';
        document.getElementById('theta-bar').style.width = (theta / Math.PI * 100) + '%';
        document.getElementById('phi-bar').style.width = (((phi + 2*Math.PI) % (2*Math.PI)) / (2*Math.PI) * 100) + '%';
        var x = Math.sin(theta) * Math.cos(phi);
        var y = Math.sin(theta) * Math.sin(phi);
        var z = Math.cos(theta);
        document.getElementById('current-coords').textContent = 'x=' + x.toFixed(2) + ', y=' + y.toFixed(2) + ', z=' + z.toFixed(2);
        var name = '';
        if (theta < 0.1) name = '|0\u27E9';
        else if (Math.abs(theta - Math.PI) < 0.1) name = '|1\u27E9';
        else if (Math.abs(theta - Math.PI/2) < 0.1) {
            var pn = ((phi % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);
            if (pn < 0.1 || pn > 2*Math.PI - 0.1) name = '|+\u27E9';
            else if (Math.abs(pn - Math.PI) < 0.1) name = '|-\u27E9';
            else if (Math.abs(pn - Math.PI/2) < 0.1) name = '|i\u27E9';
            else if (Math.abs(pn - 3*Math.PI/2) < 0.1) name = '|-i\u27E9';
            else name = 'superposition';
        } else name = 'superposition';
        document.getElementById('current-state').textContent = name;
        document.getElementById('gate-history').textContent = gateHistory.length > 0 ? gateHistory.join(' → ') : 'None';
        stateArrow.setDirection(new THREE.Vector3(x, y, z).normalize());
    }
    
    function applyGate(g) {
        gateHistory.push(g);
        if (gateHistory.length > 8) gateHistory.shift();
        if (g === 'X') { theta = Math.PI - theta; phi = -phi; }
        else if (g === 'Y') { theta = Math.PI - theta; phi = Math.PI - phi; }
        else if (g === 'Z') { phi = phi + Math.PI; }
        else if (g === 'H') { var x = Math.sin(theta) * Math.cos(phi); var z = Math.cos(theta); theta = Math.acos(x); phi = (z >= 0) ? 0 : Math.PI; }
        else if (g === 'S') { phi = phi + Math.PI/2; }
        else if (g === 'T') { phi = phi + Math.PI/4; }
        updateDisplay();
    }
    
    function resetState() { theta = 0; phi = 0; gateHistory = []; updateDisplay(); }
    
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    
    window.addEventListener('load', init);
    window.addEventListener('resize', function() {
        var c = document.getElementById('bloch-container');
        if (c && renderer) { camera.aspect = c.clientWidth / c.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(c.clientWidth, c.clientHeight); }
    });
    </script>
</body>
</html>
