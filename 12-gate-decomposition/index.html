<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gate Decomposition - Devin's Teaching Style</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        .fourwh-box { background: linear-gradient(135deg, rgba(100,255,218,0.12), rgba(78,205,196,0.06)); border: 2px solid rgba(100,255,218,0.4); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .fourwh-box h3 { color: #64ffda; margin-bottom: 20px; font-size: 1.4em; }
        .fourwh-item { background: rgba(0,0,0,0.4); border-radius: 12px; padding: 20px; margin: 15px 0; border-left: 5px solid; }
        .fourwh-item.what { border-color: #ff6b6b; }
        .fourwh-item.why { border-color: #ffd93d; }
        .fourwh-item.when { border-color: #4ecdc4; }
        .fourwh-item.where { border-color: #a855f7; }
        .fourwh-item.how { border-color: #64ffda; }
        .fourwh-item h4 { margin-bottom: 12px; font-size: 1.2em; }
        .fourwh-item.what h4 { color: #ff6b6b; }
        .fourwh-item.why h4 { color: #ffd93d; }
        .fourwh-item.when h4 { color: #4ecdc4; }
        .fourwh-item.where h4 { color: #a855f7; }
        .fourwh-item.how h4 { color: #64ffda; }
        .fourwh-item p, .fourwh-item li { color: #ccc; line-height: 1.7; }
        .prereq-box { background: linear-gradient(135deg, rgba(168,85,247,0.1), rgba(168,85,247,0.05)); border: 2px solid rgba(168,85,247,0.3); border-radius: 16px; padding: 25px; margin: 20px 0; }
        .prereq-box h3 { color: #a855f7; margin-bottom: 15px; }
        .prereq-item { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; margin: 12px 0; border-left: 4px solid #a855f7; }
        .prereq-item h4 { color: #c084fc; margin-bottom: 8px; }
        .matrix-derivation { background: rgba(255,215,0,0.08); border: 2px solid rgba(255,215,0,0.3); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .matrix-derivation h3 { color: #ffd93d; margin-bottom: 20px; }
        .derivation-step { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 20px; margin: 15px 0; }
        .derivation-step h4 { color: #4ecdc4; margin-bottom: 12px; }
        .derivation-step .explanation { color: #ccc; line-height: 1.6; }
        .derivation-step .formula { background: rgba(100,255,218,0.1); padding: 15px; border-radius: 8px; margin: 10px 0; font-family: monospace; font-size: 1.1em; color: #64ffda; text-align: center; }
        .key-insight { background: linear-gradient(135deg, rgba(255,107,107,0.1), rgba(255,107,107,0.05)); border: 2px solid rgba(255,107,107,0.3); border-radius: 12px; padding: 20px; margin: 20px 0; }
        .key-insight h4 { color: #ff6b6b; margin-bottom: 10px; }
        .key-insight p { color: #ccc; line-height: 1.6; }
        .bloch-container { display: flex; gap: 30px; justify-content: center; flex-wrap: wrap; margin: 20px 0; }
        .bloch-main { background: rgba(0,0,0,0.5); border-radius: 16px; padding: 20px; }
        .bloch-canvas { width: 350px; height: 350px; border-radius: 12px; background: #050505; }
        .slider-group { margin: 15px 0; }
        .slider-group label { display: block; color: #64ffda; margin-bottom: 5px; font-size: 0.9em; }
        .slider-group input[type="range"] { width: 100%; }
        .slider-group .value { text-align: center; font-family: monospace; color: #fff; }
        .decomposition-display { background: rgba(0,0,0,0.4); border-radius: 12px; padding: 20px; min-width: 280px; }
        .decomposition-display h4 { color: #64ffda; margin-bottom: 15px; }
        .decomp-step { padding: 10px; margin: 8px 0; background: rgba(100,255,218,0.1); border-radius: 8px; font-family: monospace; }
        .decomp-step .gate { color: #a855f7; font-weight: bold; }
        .decomp-step .angle { color: #4ecdc4; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Gate Decomposition</h1>
            <p class="subtitle">Breaking Down Any Gate into Basic Operations</p>
        </header>

        <section class="section">
            <div class="prereq-box">
                <h3>Prerequisites</h3>
                <div class="prereq-item">
                    <h4>1. Euler Angles</h4>
                    <p>Any 3D rotation can be described by three angles (α, β, γ). Similarly, any single-qubit gate can be decomposed into three rotations: Rz(α)Ry(β)Rz(γ) (ZYZ decomposition).</p>
                </div>
                <div class="prereq-item">
                    <h4>2. Global Phase</h4>
                    <p>A global phase e^(iφ) multiplies the entire state and is unobservable. U and e^(iφ)U are physically equivalent. Decompositions often ignore global phase.</p>
                </div>
                <div class="prereq-item">
                    <h4>3. SU(2) vs U(2)</h4>
                    <p>U(2) = all 2×2 unitary matrices. SU(2) = unitaries with determinant 1 (no global phase). Any U(2) = e^(iφ) × SU(2). Decompositions typically work in SU(2).</p>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="fourwh-box">
                <h3>Gate Decomposition - The 4W+H Framework</h3>
                
                <div class="fourwh-item what">
                    <h4>WHAT is Gate Decomposition?</h4>
                    <p>Gate decomposition expresses an arbitrary quantum gate as a sequence of gates from a fixed set (usually native hardware gates). For single qubits: U = e^(iα)Rz(β)Ry(γ)Rz(δ). For multi-qubit: use CNOT + single-qubit gates.</p>
                </div>
                
                <div class="fourwh-item why">
                    <h4>WHY decompose gates?</h4>
                    <p>Hardware only implements a few native gates. Compilers must translate arbitrary gates into native ones. Decomposition enables: running any algorithm on any hardware, optimizing gate count, and understanding gate complexity.</p>
                </div>
                
                <div class="fourwh-item when">
                    <h4>WHEN to decompose?</h4>
                    <p>During compilation (algorithm → hardware). When optimizing circuits (fewer gates = less error). When analyzing algorithms (understanding structure). When implementing custom gates on hardware.</p>
                </div>
                
                <div class="fourwh-item where">
                    <h4>WHERE is decomposition used?</h4>
                    <p>Quantum compilers (Qiskit, Cirq). Hardware control systems. Circuit optimization. Fault-tolerant computing (decompose into Clifford+T). Variational algorithms (parameterized decompositions).</p>
                </div>
                
                <div class="fourwh-item how">
                    <h4>HOW to decompose a gate?</h4>
                    <p>For single-qubit U: extract Euler angles from matrix elements. For 2-qubit: use KAK decomposition (at most 3 CNOTs). For n-qubit: recursive decomposition into 2-qubit gates.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Interactive Euler Angle Explorer</h2>
            <p>Adjust the three Euler angles and see the resulting rotation on the Bloch sphere.</p>
            
            <div class="bloch-container">
                <div class="bloch-main">
                    <div id="bloch-container" class="bloch-canvas"></div>
                    <div class="slider-group">
                        <label>α (first Rz): <span id="alpha-val">0°</span></label>
                        <input type="range" id="alpha" min="0" max="360" value="0" oninput="updateDecomposition()">
                    </div>
                    <div class="slider-group">
                        <label>β (Ry): <span id="beta-val">0°</span></label>
                        <input type="range" id="beta" min="0" max="180" value="0" oninput="updateDecomposition()">
                    </div>
                    <div class="slider-group">
                        <label>γ (second Rz): <span id="gamma-val">0°</span></label>
                        <input type="range" id="gamma" min="0" max="360" value="0" oninput="updateDecomposition()">
                    </div>
                </div>
                <div class="decomposition-display">
                    <h4>ZYZ Decomposition</h4>
                    <div class="decomp-step">
                        <span class="gate">Rz(</span><span class="angle" id="d-alpha">0°</span><span class="gate">)</span>
                        <span style="color:#888;"> → rotate around Z</span>
                    </div>
                    <div class="decomp-step">
                        <span class="gate">Ry(</span><span class="angle" id="d-beta">0°</span><span class="gate">)</span>
                        <span style="color:#888;"> → rotate around Y</span>
                    </div>
                    <div class="decomp-step">
                        <span class="gate">Rz(</span><span class="angle" id="d-gamma">0°</span><span class="gate">)</span>
                        <span style="color:#888;"> → rotate around Z</span>
                    </div>
                    <div style="margin-top:20px;padding:15px;background:rgba(100,255,218,0.1);border-radius:8px;">
                        <p style="color:#64ffda;margin:0;font-size:0.9em;"><strong>Final State:</strong></p>
                        <p style="color:#fff;font-family:monospace;margin:5px 0 0 0;" id="final-state">|0⟩</p>
                    </div>
                    <div style="margin-top:15px;padding:15px;background:rgba(168,85,247,0.1);border-radius:8px;">
                        <p style="color:#a855f7;margin:0;font-size:0.9em;"><strong>Equivalent to:</strong></p>
                        <p style="color:#ccc;font-size:0.85em;margin:5px 0 0 0;" id="equivalent-gate">Identity</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="matrix-derivation">
                <h3>ZYZ Decomposition Formula</h3>
                <div class="derivation-step">
                    <h4>The General Form</h4>
                    <p class="explanation">Any single-qubit unitary U ∈ SU(2) can be written as:</p>
                    <div class="formula">U = e^(iα) · Rz(β) · Ry(γ) · Rz(δ)</div>
                    <p class="explanation">where α is a global phase (often ignored), and β, γ, δ are the Euler angles.</p>
                </div>
                <div class="derivation-step">
                    <h4>Extracting Angles from Matrix</h4>
                    <p class="explanation">Given U = [[a,b],[c,d]], the angles can be computed:</p>
                    <div class="formula">γ = 2·arccos(|a|)</div>
                    <div class="formula">β = arg(a) - arg(c) (if γ ≠ 0)</div>
                    <div class="formula">δ = arg(a) + arg(c) (if γ ≠ 0)</div>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="matrix-derivation">
                <h3>Common Gate Decompositions</h3>
                <div class="derivation-step">
                    <h4>Hadamard Gate</h4>
                    <div class="formula">H = Rz(π) · Ry(π/2) = Ry(π/2) · Rz(π)</div>
                </div>
                <div class="derivation-step">
                    <h4>X Gate (NOT)</h4>
                    <div class="formula">X = Ry(π) (up to global phase)</div>
                </div>
                <div class="derivation-step">
                    <h4>S Gate</h4>
                    <div class="formula">S = Rz(π/2) (up to global phase)</div>
                </div>
                <div class="derivation-step">
                    <h4>T Gate</h4>
                    <div class="formula">T = Rz(π/4) (up to global phase)</div>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="key-insight">
                <h4>Key Insight: Two-Qubit Decomposition</h4>
                <p>Any 2-qubit gate can be decomposed into at most 3 CNOTs and single-qubit gates (KAK decomposition). Some gates need fewer: SWAP = 3 CNOTs, CZ = 1 CNOT + H gates, iSWAP = 2 CNOTs. Minimizing CNOT count is crucial for noisy hardware.</p>
            </div>
        </section>

        <div class="nav-buttons">
            <a href="../11-universal-gate-sets/index.html" class="btn">Previous: Universal Gate Sets</a>
            <a href="../13-bloch-sphere-visualization/index.html" class="btn btn-primary">Next: Bloch Sphere</a>
        </div>
    </div>

    <script>
    let scene, camera, renderer, controls, stateArrow;
    let theta = 0, phi = 0;
    
    function init() {
        const container = document.getElementById('bloch-container');
        if (!container) return;
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        
        camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(3, 2.5, 3);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        
        const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
        const sphereMat = new THREE.MeshBasicMaterial({ color: 0x64ffda, transparent: true, opacity: 0.1, wireframe: true });
        scene.add(new THREE.Mesh(sphereGeo, sphereMat));
        
        createAxis(new THREE.Vector3(1, 0, 0), 0xff6b6b, 'X');
        createAxis(new THREE.Vector3(0, 1, 0), 0x4ecdc4, 'Y');
        createAxis(new THREE.Vector3(0, 0, 1), 0xffd93d, 'Z');
        
        stateArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1.1, 0x64ffda, 0.15, 0.1);
        scene.add(stateArrow);
        
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        animate();
        updateDecomposition();
    }
    
    function createAxis(dir, color, label) {
        scene.add(new THREE.ArrowHelper(dir, new THREE.Vector3(0,0,0), 1.4, color, 0.08, 0.05));
        scene.add(new THREE.ArrowHelper(dir.clone().negate(), new THREE.Vector3(0,0,0), 1.4, color, 0.08, 0.05));
    }
    
    function updateDecomposition() {
        var alpha = parseFloat(document.getElementById('alpha').value);
        var beta = parseFloat(document.getElementById('beta').value);
        var gamma = parseFloat(document.getElementById('gamma').value);
        
        document.getElementById('alpha-val').textContent = alpha + '°';
        document.getElementById('beta-val').textContent = beta + '°';
        document.getElementById('gamma-val').textContent = gamma + '°';
        document.getElementById('d-alpha').textContent = alpha + '°';
        document.getElementById('d-beta').textContent = beta + '°';
        document.getElementById('d-gamma').textContent = gamma + '°';
        
        var aRad = alpha * Math.PI / 180;
        var bRad = beta * Math.PI / 180;
        var gRad = gamma * Math.PI / 180;
        
        theta = bRad;
        phi = aRad + gRad;
        
        var x = Math.sin(theta) * Math.cos(phi);
        var y = Math.sin(theta) * Math.sin(phi);
        var z = Math.cos(theta);
        stateArrow.setDirection(new THREE.Vector3(x, y, z).normalize());
        
        var name = '';
        if (theta < 0.1) name = '|0⟩';
        else if (Math.abs(theta - Math.PI) < 0.1) name = '|1⟩';
        else if (Math.abs(theta - Math.PI/2) < 0.1) {
            var pn = ((phi % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);
            if (pn < 0.1 || pn > 2*Math.PI - 0.1) name = '|+⟩';
            else if (Math.abs(pn - Math.PI) < 0.1) name = '|-⟩';
            else name = 'superposition';
        } else name = 'superposition';
        document.getElementById('final-state').textContent = name;
        
        var equiv = 'Custom rotation';
        if (alpha === 0 && beta === 0 && gamma === 0) equiv = 'Identity (I)';
        else if (beta === 180 && (alpha + gamma) % 360 === 0) equiv = 'X gate (NOT)';
        else if (alpha === 180 && beta === 90 && gamma === 0) equiv = 'Hadamard (H)';
        else if (beta === 0 && (alpha + gamma) === 90) equiv = 'S gate';
        else if (beta === 0 && (alpha + gamma) === 45) equiv = 'T gate';
        document.getElementById('equivalent-gate').textContent = equiv;
    }
    
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    
    window.addEventListener('load', init);
    </script>
</body>
</html>
