<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotation Gates - Quantum Gates Learning</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        .prereq-box { background: linear-gradient(135deg, rgba(100,255,218,0.1), rgba(78,205,196,0.05)); border: 2px solid rgba(100,255,218,0.3); border-radius: 16px; padding: 25px; margin: 20px 0; }
        .prereq-box h3 { color: #64ffda; margin-bottom: 15px; }
        .prereq-item { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; margin: 12px 0; border-left: 4px solid #64ffda; }
        .prereq-item h4 { color: #4ecdc4; margin-bottom: 8px; }
        .bloch-canvas { width: 100%; height: 400px; border-radius: 12px; background: #050505; }
        .gate-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; margin: 20px 0; }
        .gate-panel { background: rgba(100,255,218,0.05); border: 1px solid rgba(100,255,218,0.2); border-radius: 12px; padding: 20px; }
        .gate-panel h4 { color: #64ffda; text-align: center; margin-bottom: 15px; }
        .mini-bloch { width: 100%; height: 220px; border-radius: 8px; background: #050505; }
        .matrix-display { display: flex; justify-content: center; margin: 15px 0; }
        .matrix-box { display: inline-grid; grid-template-columns: repeat(2, 55px); gap: 2px; background: rgba(0,0,0,0.4); padding: 8px; border-radius: 6px; border: 1px solid rgba(100,255,218,0.3); }
        .matrix-box .cell { width: 55px; height: 32px; display: flex; align-items: center; justify-content: center; background: rgba(100,255,218,0.15); color: #fff; font-size: 11px; border-radius: 3px; }
        .slider-section { background: rgba(100,255,218,0.08); border-radius: 12px; padding: 20px; margin: 15px 0; }
        .slider-group { margin: 15px 0; }
        .slider-label { display: flex; justify-content: space-between; margin-bottom: 8px; color: #fff; }
        .slider-label .name { font-weight: bold; }
        .slider-label .value { color: #64ffda; font-family: monospace; }
        input[type="range"] { width: 100%; height: 8px; border-radius: 4px; background: rgba(100,255,218,0.2); outline: none; -webkit-appearance: none; }
        input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: linear-gradient(135deg, #64ffda, #4ecdc4); cursor: pointer; }
        .interactive-section { background: linear-gradient(135deg, rgba(100,255,218,0.08), rgba(78,205,196,0.03)); border: 2px solid rgba(100,255,218,0.3); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .demo-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin-bottom: 20px; }
        .demo-btn { padding: 10px 20px; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; font-weight: bold; transition: all 0.3s; }
        .btn-rx { background: linear-gradient(135deg, #ff6b6b, #ff8e8e); color: #fff; }
        .btn-ry { background: linear-gradient(135deg, #4ecdc4, #6ee7de); color: #000; }
        .btn-rz { background: linear-gradient(135deg, #ffd93d, #ffe66d); color: #000; }
        .btn-reset { background: linear-gradient(135deg, #666, #888); color: #fff; }
        .demo-btn:hover { transform: scale(1.05); box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .state-display { text-align: center; font-size: 20px; color: #64ffda; margin-top: 15px; font-family: monospace; }
        .amp-bars { display: flex; justify-content: center; gap: 40px; margin-top: 20px; }
        .amp-bar { text-align: center; }
        .bar-container { width: 60px; height: 140px; background: rgba(0,0,0,0.4); border-radius: 8px; position: relative; overflow: hidden; border: 1px solid rgba(100,255,218,0.2); }
        .bar-fill { position: absolute; bottom: 0; width: 100%; background: linear-gradient(to top, #64ffda, #4ecdc4); transition: height 0.4s; border-radius: 0 0 8px 8px; }
        .bar-label { margin-top: 8px; color: #fff; font-size: 16px; font-family: monospace; }
        .bar-value { position: absolute; width: 100%; text-align: center; bottom: 5px; color: #000; font-weight: bold; font-size: 12px; }
        .decision-guide { background: rgba(255,215,0,0.1); border: 1px solid rgba(255,215,0,0.3); border-radius: 12px; padding: 20px; margin: 20px 0; }
        .decision-guide h3 { color: #ffd93d; margin-bottom: 15px; }
        .decision-item { display: flex; align-items: flex-start; gap: 15px; padding: 12px; background: rgba(0,0,0,0.2); border-radius: 8px; margin: 10px 0; }
        .decision-item .goal { color: #4ecdc4; font-weight: bold; min-width: 200px; }
        .decision-item .solution { color: #fff; }
        .decision-item .gate { color: #ff6b6b; font-weight: bold; }
        .relationship-table { width: 100%; border-collapse: collapse; margin: 15px 0; }
        .relationship-table th, .relationship-table td { padding: 12px; text-align: center; border: 1px solid rgba(100,255,218,0.2); }
        .relationship-table th { background: rgba(100,255,218,0.1); color: #64ffda; }
        .relationship-table td { background: rgba(0,0,0,0.2); }
        .axis-indicator { display: flex; justify-content: center; gap: 30px; margin: 15px 0; }
        .axis-item { display: flex; align-items: center; gap: 8px; }
        .axis-dot { width: 16px; height: 16px; border-radius: 50%; }
        .axis-x { background: #ff6b6b; }
        .axis-y { background: #4ecdc4; }
        .axis-z { background: #ffd93d; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Rotation Gates</h1>
            <p class="subtitle">Rx, Ry, Rz - Continuous Rotations on the Bloch Sphere</p>
        </header>

        <section class="section">
            <div class="prereq-box">
                <h3>Prerequisites</h3>
                <div class="prereq-item">
                    <h4>1. Pauli Gates as π Rotations</h4>
                    <p>X, Y, Z gates are 180° (π) rotations around their respective axes. Rotation gates generalize this to <strong>any angle θ</strong>.</p>
                </div>
                <div class="prereq-item">
                    <h4>2. Radians vs Degrees</h4>
                    <p>Angles are in radians: π = 180°, π/2 = 90°, π/4 = 45°. A full rotation is 2π = 360°.</p>
                </div>
                <div class="prereq-item">
                    <h4>3. Bloch Sphere Axes</h4>
                    <p><span style="color:#ff6b6b;">X-axis</span> (red): |+⟩ to |-⟩ | <span style="color:#4ecdc4;">Y-axis</span> (cyan): |i⟩ to |-i⟩ | <span style="color:#ffd93d;">Z-axis</span> (yellow): |0⟩ to |1⟩</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>The Three Rotation Gates</h2>
            <div class="axis-indicator">
                <div class="axis-item"><div class="axis-dot axis-x"></div><span>X-axis (Rx)</span></div>
                <div class="axis-item"><div class="axis-dot axis-y"></div><span>Y-axis (Ry)</span></div>
                <div class="axis-item"><div class="axis-dot axis-z"></div><span>Z-axis (Rz)</span></div>
            </div>
            
            <div class="gate-grid">
                <div class="gate-panel">
                    <h4>Rx(θ) - X-axis Rotation</h4>
                    <div id="bloch-rx" class="mini-bloch"></div>
                    <div class="matrix-display">
                        <div class="matrix-box">
                            <div class="cell">cos(θ/2)</div><div class="cell">-i·sin(θ/2)</div>
                            <div class="cell">-i·sin(θ/2)</div><div class="cell">cos(θ/2)</div>
                        </div>
                    </div>
                    <p style="color:#ff6b6b;text-align:center;font-size:13px;">Rx(π) = -iX (X gate with global phase)</p>
                </div>
                <div class="gate-panel">
                    <h4>Ry(θ) - Y-axis Rotation</h4>
                    <div id="bloch-ry" class="mini-bloch"></div>
                    <div class="matrix-display">
                        <div class="matrix-box">
                            <div class="cell">cos(θ/2)</div><div class="cell">-sin(θ/2)</div>
                            <div class="cell">sin(θ/2)</div><div class="cell">cos(θ/2)</div>
                        </div>
                    </div>
                    <p style="color:#4ecdc4;text-align:center;font-size:13px;">Ry(π) = -iY (Y gate with global phase)</p>
                </div>
                <div class="gate-panel">
                    <h4>Rz(θ) - Z-axis Rotation</h4>
                    <div id="bloch-rz" class="mini-bloch"></div>
                    <div class="matrix-display">
                        <div class="matrix-box">
                            <div class="cell">e^(-iθ/2)</div><div class="cell">0</div>
                            <div class="cell">0</div><div class="cell">e^(iθ/2)</div>
                        </div>
                    </div>
                    <p style="color:#ffd93d;text-align:center;font-size:13px;">Rz(π) = -iZ (Z gate with global phase)</p>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="decision-guide">
                <h3>Which Rotation Gate Should I Use?</h3>
                <div class="decision-item">
                    <span class="goal">Rotate between |0⟩ and |1⟩:</span>
                    <span class="solution">Use <span class="gate">Ry(θ)</span> - moves along the meridian</span>
                </div>
                <div class="decision-item">
                    <span class="goal">Add phase to superposition:</span>
                    <span class="solution">Use <span class="gate">Rz(θ)</span> - rotates around equator</span>
                </div>
                <div class="decision-item">
                    <span class="goal">Rotate |+⟩ toward |1⟩:</span>
                    <span class="solution">Use <span class="gate">Rx(θ)</span> - rotates in YZ plane</span>
                </div>
                <div class="decision-item">
                    <span class="goal">Create partial superposition:</span>
                    <span class="solution">Use <span class="gate">Ry(θ)</span> with θ < π for controlled mixing</span>
                </div>
                <div class="decision-item">
                    <span class="goal">Implement arbitrary single-qubit gate:</span>
                    <span class="solution">Use <span class="gate">Rz(α)Ry(β)Rz(γ)</span> - Euler decomposition</span>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Interactive Rotation Explorer</h2>
            <p>Use the sliders to rotate the qubit state around any axis:</p>
            <div class="interactive-section">
                <div class="slider-section">
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="name" style="color:#ff6b6b;">Rx (X-axis rotation)</span>
                            <span class="value" id="rx-val">0°</span>
                        </div>
                        <input type="range" id="rx-slider" min="-180" max="180" value="0" oninput="updateRotation()">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="name" style="color:#4ecdc4;">Ry (Y-axis rotation)</span>
                            <span class="value" id="ry-val">0°</span>
                        </div>
                        <input type="range" id="ry-slider" min="-180" max="180" value="0" oninput="updateRotation()">
                    </div>
                    <div class="slider-group">
                        <div class="slider-label">
                            <span class="name" style="color:#ffd93d;">Rz (Z-axis rotation)</span>
                            <span class="value" id="rz-val">0°</span>
                        </div>
                        <input type="range" id="rz-slider" min="-180" max="180" value="0" oninput="updateRotation()">
                    </div>
                </div>
                <div class="demo-controls">
                    <button class="demo-btn btn-rx" onclick="applyPreset('rx90')">Rx(90°)</button>
                    <button class="demo-btn btn-ry" onclick="applyPreset('ry90')">Ry(90°)</button>
                    <button class="demo-btn btn-rz" onclick="applyPreset('rz90')">Rz(90°)</button>
                    <button class="demo-btn btn-reset" onclick="resetAll()">Reset</button>
                </div>
                <div id="main-bloch" class="bloch-canvas"></div>
                <div class="state-display" id="current-state">Current State: |0⟩</div>
                <div class="amp-bars">
                    <div class="amp-bar">
                        <div class="bar-container"><div class="bar-fill" id="bar-0" style="height:100%;"></div><div class="bar-value" id="val-0">1.00</div></div>
                        <div class="bar-label">|0⟩</div>
                    </div>
                    <div class="amp-bar">
                        <div class="bar-container"><div class="bar-fill" id="bar-1" style="height:0%;"></div><div class="bar-value" id="val-1">0.00</div></div>
                        <div class="bar-label">|1⟩</div>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Relationship to Fixed Gates</h2>
            <table class="relationship-table">
                <tr>
                    <th>Rotation</th>
                    <th>Equivalent Gate</th>
                    <th>Effect</th>
                </tr>
                <tr>
                    <td style="color:#ff6b6b;">Rx(π)</td>
                    <td>X (up to global phase)</td>
                    <td>Bit flip</td>
                </tr>
                <tr>
                    <td style="color:#4ecdc4;">Ry(π)</td>
                    <td>Y (up to global phase)</td>
                    <td>Bit + phase flip</td>
                </tr>
                <tr>
                    <td style="color:#ffd93d;">Rz(π)</td>
                    <td>Z (up to global phase)</td>
                    <td>Phase flip</td>
                </tr>
                <tr>
                    <td style="color:#ffd93d;">Rz(π/2)</td>
                    <td>S (up to global phase)</td>
                    <td>90° phase</td>
                </tr>
                <tr>
                    <td style="color:#ffd93d;">Rz(π/4)</td>
                    <td>T (up to global phase)</td>
                    <td>45° phase</td>
                </tr>
            </table>
        </section>

        <section class="section">
            <h2>Euler Decomposition</h2>
            <div class="highlight">
                <h3>Any Single-Qubit Gate = Rz · Ry · Rz</h3>
                <p>Any single-qubit unitary can be decomposed as:</p>
                <p style="text-align:center;font-size:18px;margin:15px 0;color:#64ffda;">U = e^(iα) · Rz(β) · Ry(γ) · Rz(δ)</p>
                <p style="color:#888;">This is called the ZYZ decomposition. It means you only need Ry and Rz to build any single-qubit gate!</p>
            </div>
        </section>

        <div class="nav-buttons">
            <a href="../05-hadamard-gate/index.html" class="btn">Previous: Hadamard Gate</a>
            <a href="../07-multiple-qubit-gates/index.html" class="btn btn-primary">Next: Multiple-Qubit Gates</a>
        </div>
    </div>

    <script>
    function createRotBloch(id, axis, color) {
        const c = document.getElementById(id);
        if (!c) return;
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        const camera = new THREE.PerspectiveCamera(50, c.clientWidth/c.clientHeight, 0.1, 1000);
        camera.position.set(1.8, 1.2, 1.8);
        const renderer = new THREE.WebGLRenderer({antialias:true});
        renderer.setSize(c.clientWidth, c.clientHeight);
        c.appendChild(renderer.domElement);
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.enableZoom = false;
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.5));
        const light = new THREE.PointLight(0xffffff, 0.8);
        light.position.set(5,5,5);
        scene.add(light);
        
        scene.add(new THREE.Mesh(new THREE.SphereGeometry(1,24,24), new THREE.MeshPhongMaterial({color:0x64ffda,transparent:true,opacity:0.08})));
        scene.add(new THREE.Mesh(new THREE.SphereGeometry(1,12,12), new THREE.MeshBasicMaterial({color:0x64ffda,wireframe:true,transparent:true,opacity:0.1})));
        
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1.1, 0xff6b6b, 0.06, 0.03));
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 1.1, 0x4ecdc4, 0.06, 0.03));
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 1.1, 0xffd93d, 0.06, 0.03));
        
        const ring = new THREE.Mesh(new THREE.TorusGeometry(0.85,0.02,16,100), new THREE.MeshBasicMaterial({color:color,transparent:true,opacity:0.5}));
        if(axis==='x') ring.rotation.y = Math.PI/2;
        else if(axis==='y') ring.rotation.x = Math.PI/2;
        scene.add(ring);
        
        const arrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 1, 0xffffff, 0.08, 0.05);
        scene.add(arrow);
        
        let angle = 0;
        function animate() {
            requestAnimationFrame(animate);
            angle += 0.02;
            let dir = new THREE.Vector3(0,0,1);
            if(axis==='x') dir.applyAxisAngle(new THREE.Vector3(1,0,0), angle);
            else if(axis==='y') dir.applyAxisAngle(new THREE.Vector3(0,1,0), angle);
            else if(axis==='z') dir.applyAxisAngle(new THREE.Vector3(0,0,1), angle);
            arrow.setDirection(dir.normalize());
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
    }
    
    createRotBloch('bloch-rx', 'x', 0xff6b6b);
    createRotBloch('bloch-ry', 'y', 0x4ecdc4);
    createRotBloch('bloch-rz', 'z', 0xffd93d);

    const mainC = document.getElementById('main-bloch');
    const mainScene = new THREE.Scene();
    mainScene.background = new THREE.Color(0x050505);
    const mainCam = new THREE.PerspectiveCamera(50, mainC.clientWidth/mainC.clientHeight, 0.1, 1000);
    mainCam.position.set(2.5, 2, 2.5);
    const mainRend = new THREE.WebGLRenderer({antialias:true});
    mainRend.setSize(mainC.clientWidth, mainC.clientHeight);
    mainC.appendChild(mainRend.domElement);
    const mainCtrl = new THREE.OrbitControls(mainCam, mainRend.domElement);
    mainCtrl.enableDamping = true;
    
    mainScene.add(new THREE.AmbientLight(0xffffff, 0.5));
    const ml = new THREE.PointLight(0xffffff, 0.8);
    ml.position.set(10,10,10);
    mainScene.add(ml);
    
    mainScene.add(new THREE.Mesh(new THREE.SphereGeometry(1,32,32), new THREE.MeshPhongMaterial({color:0x64ffda,transparent:true,opacity:0.1})));
    mainScene.add(new THREE.Mesh(new THREE.SphereGeometry(1,16,16), new THREE.MeshBasicMaterial({color:0x64ffda,wireframe:true,transparent:true,opacity:0.15})));
    
    mainScene.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1.3, 0xff6b6b, 0.1, 0.05));
    mainScene.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 1.3, 0x4ecdc4, 0.1, 0.05));
    mainScene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 1.3, 0xffd93d, 0.1, 0.05));
    
    ['x','y','z'].forEach((a,i) => {
        const colors = [0xff6b6b, 0x4ecdc4, 0xffd93d];
        const r = new THREE.Mesh(new THREE.TorusGeometry(0.9,0.01,16,100), new THREE.MeshBasicMaterial({color:colors[i],transparent:true,opacity:0.2}));
        if(a==='x') r.rotation.y = Math.PI/2;
        else if(a==='y') r.rotation.x = Math.PI/2;
        mainScene.add(r);
    });
    
    const mainArrow = new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 1, 0xffffff, 0.12, 0.08);
    mainScene.add(mainArrow);

    function updateRotation() {
        const rx = parseFloat(document.getElementById('rx-slider').value) * Math.PI / 180;
        const ry = parseFloat(document.getElementById('ry-slider').value) * Math.PI / 180;
        const rz = parseFloat(document.getElementById('rz-slider').value) * Math.PI / 180;
        
        document.getElementById('rx-val').textContent = document.getElementById('rx-slider').value + '°';
        document.getElementById('ry-val').textContent = document.getElementById('ry-slider').value + '°';
        document.getElementById('rz-val').textContent = document.getElementById('rz-slider').value + '°';
        
        let dir = new THREE.Vector3(0, 0, 1);
        dir.applyAxisAngle(new THREE.Vector3(1, 0, 0), rx);
        dir.applyAxisAngle(new THREE.Vector3(0, 1, 0), ry);
        dir.applyAxisAngle(new THREE.Vector3(0, 0, 1), rz);
        mainArrow.setDirection(dir.normalize());
        
        const theta = Math.acos(dir.z);
        const phi = Math.atan2(dir.y, dir.x);
        
        const a0 = Math.abs(Math.cos(theta/2)), a1 = Math.abs(Math.sin(theta/2));
        document.getElementById('bar-0').style.height = (a0*100)+'%';
        document.getElementById('bar-1').style.height = (a1*100)+'%';
        document.getElementById('val-0').textContent = a0.toFixed(2);
        document.getElementById('val-1').textContent = a1.toFixed(2);
        
        let s = 'Superposition';
        const e = 0.1;
        if(theta < e) s = '|0⟩';
        else if(Math.abs(theta-Math.PI) < e) s = '|1⟩';
        else if(Math.abs(theta-Math.PI/2) < e) {
            const normPhi = ((phi % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);
            if(normPhi < e || Math.abs(normPhi-2*Math.PI) < e) s = '|+⟩';
            else if(Math.abs(normPhi-Math.PI) < e) s = '|-⟩';
            else if(Math.abs(normPhi-Math.PI/2) < e) s = '|i⟩';
            else if(Math.abs(normPhi-3*Math.PI/2) < e) s = '|-i⟩';
        }
        document.getElementById('current-state').textContent = 'Current State: ' + s;
    }

    function applyPreset(preset) {
        document.getElementById('rx-slider').value = 0;
        document.getElementById('ry-slider').value = 0;
        document.getElementById('rz-slider').value = 0;
        if(preset === 'rx90') document.getElementById('rx-slider').value = 90;
        else if(preset === 'ry90') document.getElementById('ry-slider').value = 90;
        else if(preset === 'rz90') document.getElementById('rz-slider').value = 90;
        updateRotation();
    }

    function resetAll() {
        document.getElementById('rx-slider').value = 0;
        document.getElementById('ry-slider').value = 0;
        document.getElementById('rz-slider').value = 0;
        updateRotation();
    }

    function mainAnim() {
        requestAnimationFrame(mainAnim);
        mainCtrl.update();
        mainRend.render(mainScene, mainCam);
    }
    mainAnim();
    updateRotation();

    window.addEventListener('resize', () => {
        mainCam.aspect = mainC.clientWidth/mainC.clientHeight;
        mainCam.updateProjectionMatrix();
        mainRend.setSize(mainC.clientWidth, mainC.clientHeight);
    });
    </script>
</body>
</html>
