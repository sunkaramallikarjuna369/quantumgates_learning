<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotation Gates (Rx, Ry, Rz) - Devin's Teaching Style</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        .fourwh-box { background: linear-gradient(135deg, rgba(100,255,218,0.12), rgba(78,205,196,0.06)); border: 2px solid rgba(100,255,218,0.4); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .fourwh-box h3 { color: #64ffda; margin-bottom: 20px; font-size: 1.4em; }
        .fourwh-item { background: rgba(0,0,0,0.4); border-radius: 12px; padding: 20px; margin: 15px 0; border-left: 5px solid; }
        .fourwh-item.what { border-color: #ff6b6b; }
        .fourwh-item.why { border-color: #ffd93d; }
        .fourwh-item.when { border-color: #4ecdc4; }
        .fourwh-item.where { border-color: #a855f7; }
        .fourwh-item.how { border-color: #64ffda; }
        .fourwh-item h4 { margin-bottom: 12px; font-size: 1.2em; }
        .fourwh-item.what h4 { color: #ff6b6b; }
        .fourwh-item.why h4 { color: #ffd93d; }
        .fourwh-item.when h4 { color: #4ecdc4; }
        .fourwh-item.where h4 { color: #a855f7; }
        .fourwh-item.how h4 { color: #64ffda; }
        .fourwh-item p, .fourwh-item li { color: #ccc; line-height: 1.7; }
        .prereq-box { background: linear-gradient(135deg, rgba(168,85,247,0.1), rgba(168,85,247,0.05)); border: 2px solid rgba(168,85,247,0.3); border-radius: 16px; padding: 25px; margin: 20px 0; }
        .prereq-box h3 { color: #a855f7; margin-bottom: 15px; }
        .prereq-item { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; margin: 12px 0; border-left: 4px solid #a855f7; }
        .prereq-item h4 { color: #c084fc; margin-bottom: 8px; }
        .bloch-container { display: flex; gap: 30px; justify-content: center; flex-wrap: wrap; margin: 20px 0; }
        .bloch-main { background: rgba(0,0,0,0.5); border-radius: 16px; padding: 20px; }
        .bloch-canvas { width: 400px; height: 400px; border-radius: 12px; background: #050505; }
        .angle-display { background: rgba(0,0,0,0.6); border-radius: 12px; padding: 20px; min-width: 300px; }
        .angle-display h4 { color: #64ffda; margin-bottom: 15px; text-align: center; }
        .angle-item { display: flex; justify-content: space-between; align-items: center; padding: 12px; margin: 8px 0; background: rgba(100,255,218,0.1); border-radius: 8px; }
        .angle-name { font-weight: bold; }
        .angle-name.theta { color: #ff6b6b; }
        .angle-name.phi { color: #4ecdc4; }
        .angle-value { font-family: monospace; font-size: 1.1em; color: #fff; }
        .angle-bar { width: 100%; height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; margin-top: 8px; overflow: hidden; }
        .angle-bar-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }
        .angle-bar-fill.theta { background: linear-gradient(90deg, #ff6b6b, #ff8e8e); }
        .angle-bar-fill.phi { background: linear-gradient(90deg, #4ecdc4, #6ee7de); }
        .state-info { text-align: center; margin-top: 15px; padding: 15px; background: rgba(100,255,218,0.1); border-radius: 8px; }
        .state-info .state { font-size: 1.3em; color: #64ffda; font-family: monospace; }
        .state-info .coords { color: #888; font-size: 0.9em; margin-top: 8px; }
        .matrix-derivation { background: rgba(255,215,0,0.08); border: 2px solid rgba(255,215,0,0.3); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .matrix-derivation h3 { color: #ffd93d; margin-bottom: 20px; }
        .derivation-step { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 20px; margin: 15px 0; }
        .derivation-step h4 { color: #4ecdc4; margin-bottom: 12px; }
        .derivation-step .explanation { color: #ccc; line-height: 1.6; }
        .derivation-step .formula { background: rgba(100,255,218,0.1); padding: 15px; border-radius: 8px; margin: 10px 0; font-family: monospace; font-size: 1.1em; color: #64ffda; text-align: center; }
        .matrix-visual { display: flex; align-items: center; justify-content: center; gap: 15px; margin: 20px 0; flex-wrap: wrap; }
        .matrix-box { display: inline-grid; grid-template-columns: repeat(2, 70px); gap: 4px; background: rgba(0,0,0,0.5); padding: 12px; border-radius: 10px; border: 2px solid rgba(100,255,218,0.3); }
        .matrix-box .cell { width: 70px; height: 40px; display: flex; align-items: center; justify-content: center; background: rgba(100,255,218,0.15); color: #fff; font-size: 12px; border-radius: 5px; font-family: monospace; }
        .interactive-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 20px 0; }
        .ctrl-btn { padding: 12px 24px; border: none; border-radius: 10px; font-size: 15px; cursor: pointer; font-weight: bold; transition: all 0.3s; }
        .ctrl-btn:hover { transform: scale(1.05); box-shadow: 0 4px 20px rgba(0,0,0,0.4); }
        .btn-rx { background: linear-gradient(135deg, #ff6b6b, #ff8e8e); color: #fff; }
        .btn-ry { background: linear-gradient(135deg, #4ecdc4, #6ee7de); color: #000; }
        .btn-rz { background: linear-gradient(135deg, #ffd93d, #ffe66d); color: #000; }
        .btn-reset { background: linear-gradient(135deg, #666, #888); color: #fff; }
        .gate-card { background: rgba(0,0,0,0.4); border-radius: 16px; padding: 25px; margin: 25px 0; border: 2px solid; }
        .gate-card.rx-card { border-color: rgba(255,107,107,0.5); }
        .gate-card.ry-card { border-color: rgba(78,205,196,0.5); }
        .gate-card.rz-card { border-color: rgba(255,217,61,0.5); }
        .gate-card h3 { margin-bottom: 20px; }
        .gate-card.rx-card h3 { color: #ff6b6b; }
        .gate-card.ry-card h3 { color: #4ecdc4; }
        .gate-card.rz-card h3 { color: #ffd93d; }
        .key-insight { background: linear-gradient(135deg, rgba(255,107,107,0.1), rgba(255,107,107,0.05)); border: 2px solid rgba(255,107,107,0.3); border-radius: 12px; padding: 20px; margin: 20px 0; }
        .key-insight h4 { color: #ff6b6b; margin-bottom: 10px; }
        .key-insight p { color: #ccc; line-height: 1.6; }
        .slider-container { margin: 15px 0; }
        .slider-container label { display: block; color: #64ffda; margin-bottom: 8px; font-weight: bold; }
        .slider-container input[type="range"] { width: 100%; height: 8px; border-radius: 4px; background: rgba(100,255,218,0.2); outline: none; -webkit-appearance: none; }
        .slider-container input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 20px; height: 20px; border-radius: 50%; background: #64ffda; cursor: pointer; }
        .slider-value { text-align: center; font-family: monospace; font-size: 1.2em; color: #fff; margin-top: 8px; }
        .relation-box { background: rgba(100,255,218,0.08); border: 2px solid rgba(100,255,218,0.3); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .relation-box h3 { color: #64ffda; margin-bottom: 20px; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Rotation Gates: Rx, Ry, Rz</h1>
            <p class="subtitle">Continuous Rotations - Any Angle, Any Axis</p>
        </header>

        <section class="section">
            <div class="prereq-box">
                <h3>Prerequisites - Understanding Rotations</h3>
                <div class="prereq-item">
                    <h4>1. Euler's Formula</h4>
                    <p>e^(iθ) = cos(θ) + i·sin(θ). This connects exponentials to rotations. A rotation by angle θ around an axis is represented by e^(-iθσ/2) where σ is the Pauli matrix for that axis.</p>
                </div>
                <div class="prereq-item">
                    <h4>2. Why θ/2?</h4>
                    <p>Qubits are spin-1/2 particles. A 360° rotation in physical space corresponds to a 180° rotation on the Bloch sphere. So Rz(2π) = -I (not I!). This is the famous "spinor" property.</p>
                </div>
                <div class="prereq-item">
                    <h4>3. Pauli Matrices as Generators</h4>
                    <p>X, Y, Z "generate" rotations around their respective axes. Rx(θ) = e^(-iθX/2), Ry(θ) = e^(-iθY/2), Rz(θ) = e^(-iθZ/2). The Pauli matrices are the "infinitesimal generators" of rotations.</p>
                </div>
                <div class="prereq-item">
                    <h4>4. Bloch Sphere Geometry</h4>
                    <p>Rx rotates around the X-axis (red). Ry rotates around the Y-axis (cyan). Rz rotates around the Z-axis (yellow). States on the rotation axis don't change (they're eigenstates)!</p>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="fourwh-box">
                <h3>Rotation Gates - The 4W+H Framework</h3>
                
                <div class="fourwh-item what">
                    <h4>WHAT are Rotation Gates?</h4>
                    <p>Rotation gates Rx(θ), Ry(θ), Rz(θ) rotate the qubit state by angle θ around the X, Y, or Z axis of the Bloch sphere. Unlike fixed gates (X, Y, Z, H), rotation gates take a continuous parameter θ, allowing any rotation angle.</p>
                </div>
                
                <div class="fourwh-item why">
                    <h4>WHY do we need parametric rotations?</h4>
                    <p>Fixed gates only give discrete rotations (90°, 180°). Many quantum algorithms need precise angles: Quantum Phase Estimation uses controlled rotations with angles π/2^k. Variational algorithms (VQE, QAOA) optimize rotation angles. Hardware calibration requires fine-tuned rotations.</p>
                </div>
                
                <div class="fourwh-item when">
                    <h4>WHEN to use each rotation?</h4>
                    <p><strong>Rx(θ):</strong> Rotate around X-axis, changes Z-component. <strong>Ry(θ):</strong> Rotate around Y-axis, creates real superpositions. <strong>Rz(θ):</strong> Rotate around Z-axis, adds phase (like S, T but continuous). Use Rz for phase, Ry for amplitude, Rx for both.</p>
                </div>
                
                <div class="fourwh-item where">
                    <h4>WHERE in quantum circuits?</h4>
                    <p>Rotation gates appear in: Variational circuits (VQE, QAOA) as trainable parameters. Quantum Fourier Transform as controlled rotations. State preparation to create specific superpositions. Gate decomposition - any single-qubit gate = Rz(α)Ry(β)Rz(γ).</p>
                </div>
                
                <div class="fourwh-item how">
                    <h4>HOW do the matrices work?</h4>
                    <p>Each rotation matrix uses cos(θ/2) and sin(θ/2). The θ/2 comes from spin-1/2 physics. Rx uses real sin/cos. Ry uses real sin/cos. Rz uses complex exponentials e^(±iθ/2). All are unitary with determinant 1.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Interactive Rotation Explorer</h2>
            <p>Adjust the angle slider and apply rotations. Watch how θ and φ change!</p>
            
            <div class="bloch-container">
                <div class="bloch-main">
                    <div id="bloch-container" class="bloch-canvas"></div>
                    <div class="slider-container">
                        <label>Rotation Angle: <span id="angle-display">π/2 (90°)</span></label>
                        <input type="range" id="angle-slider" min="0" max="360" value="90" oninput="updateAngleDisplay()">
                    </div>
                    <div class="interactive-controls">
                        <button class="ctrl-btn btn-rx" onclick="applyRotation('X')">Rx(θ)</button>
                        <button class="ctrl-btn btn-ry" onclick="applyRotation('Y')">Ry(θ)</button>
                        <button class="ctrl-btn btn-rz" onclick="applyRotation('Z')">Rz(θ)</button>
                        <button class="ctrl-btn btn-reset" onclick="resetState()">Reset to |0⟩</button>
                    </div>
                </div>
                <div class="angle-display">
                    <h4>Current State Angles</h4>
                    <div class="angle-item">
                        <span class="angle-name theta">θ (Theta)</span>
                        <span class="angle-value" id="theta-value">0°</span>
                    </div>
                    <div class="angle-bar"><div class="angle-bar-fill theta" id="theta-bar" style="width:0%;"></div></div>
                    <p style="color:#888;font-size:0.85em;margin-top:5px;">Polar angle from +Z axis (0° to 180°)</p>
                    
                    <div class="angle-item" style="margin-top:20px;">
                        <span class="angle-name phi">φ (Phi)</span>
                        <span class="angle-value" id="phi-value">0°</span>
                    </div>
                    <div class="angle-bar"><div class="angle-bar-fill phi" id="phi-bar" style="width:0%;"></div></div>
                    <p style="color:#888;font-size:0.85em;margin-top:5px;">Azimuthal angle in XY plane (0° to 360°)</p>
                    
                    <div class="state-info">
                        <div class="state" id="current-state">|0⟩</div>
                        <div class="coords" id="current-coords">x=0, y=0, z=1</div>
                    </div>
                    
                    <div style="margin-top:15px;padding:15px;background:rgba(100,255,218,0.1);border-radius:8px;">
                        <p style="color:#64ffda;font-size:0.9em;margin:0;"><strong>Last Rotation:</strong></p>
                        <p style="color:#888;font-size:0.85em;margin:5px 0 0 0;" id="rotation-info">None yet</p>
                    </div>
                </div>
            </div>
        </section>

        <div class="gate-card rx-card">
            <h3>Rx(θ) - Rotation around X-axis</h3>
            <div class="fourwh-box" style="margin-top:0;">
                <div class="fourwh-item what">
                    <h4>WHAT does Rx(θ) do?</h4>
                    <p>Rx(θ) rotates the state by angle θ around the X-axis. States on the X-axis (|+⟩, |-⟩) are unchanged. States on the Z-axis rotate toward/away from the Y-axis.</p>
                </div>
                <div class="fourwh-item why">
                    <h4>WHY is the matrix [[cos(θ/2), -i·sin(θ/2)], [-i·sin(θ/2), cos(θ/2)]]?</h4>
                    <p><strong>Derivation from exponential:</strong></p>
                    <div class="formula">Rx(θ) = e^(-iθX/2) = cos(θ/2)·I - i·sin(θ/2)·X</div>
                    <p class="explanation" style="margin-top:10px;">Using e^(iA) = cos(A)·I + i·sin(A)·(A/|A|) for Hermitian A:</p>
                    <div class="matrix-visual">
                        <span style="color:#888;">Rx(θ) = cos(θ/2)</span>
                        <div class="matrix-box" style="border-color:rgba(255,107,107,0.5);">
                            <div class="cell" style="background:rgba(255,107,107,0.2);">1</div><div class="cell" style="background:rgba(255,107,107,0.2);">0</div>
                            <div class="cell" style="background:rgba(255,107,107,0.2);">0</div><div class="cell" style="background:rgba(255,107,107,0.2);">1</div>
                        </div>
                        <span style="color:#888;">- i·sin(θ/2)</span>
                        <div class="matrix-box" style="border-color:rgba(255,107,107,0.5);">
                            <div class="cell" style="background:rgba(255,107,107,0.2);">0</div><div class="cell" style="background:rgba(255,107,107,0.2);">1</div>
                            <div class="cell" style="background:rgba(255,107,107,0.2);">1</div><div class="cell" style="background:rgba(255,107,107,0.2);">0</div>
                        </div>
                    </div>
                    <div class="matrix-visual" style="margin-top:15px;">
                        <span style="color:#888;">= </span>
                        <div class="matrix-box" style="border-color:rgba(255,107,107,0.5);">
                            <div class="cell" style="background:rgba(255,107,107,0.2);">cos(θ/2)</div><div class="cell" style="background:rgba(255,107,107,0.2);">-i·sin(θ/2)</div>
                            <div class="cell" style="background:rgba(255,107,107,0.2);">-i·sin(θ/2)</div><div class="cell" style="background:rgba(255,107,107,0.2);">cos(θ/2)</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="key-insight">
                <h4>Key Insight: Rx(π) = -iX</h4>
                <p>At θ=π: cos(π/2)=0, sin(π/2)=1. So Rx(π) = [[0,-i],[-i,0]] = -iX. This is X up to a global phase! Similarly, Rx(2π) = -I (not I), showing the spin-1/2 nature.</p>
            </div>
        </div>

        <div class="gate-card ry-card">
            <h3>Ry(θ) - Rotation around Y-axis</h3>
            <div class="fourwh-box" style="margin-top:0;">
                <div class="fourwh-item what">
                    <h4>WHAT does Ry(θ) do?</h4>
                    <p>Ry(θ) rotates the state by angle θ around the Y-axis. States on the Y-axis (|i⟩, |-i⟩) are unchanged. Ry is special: it creates REAL superpositions (no complex phases)!</p>
                </div>
                <div class="fourwh-item why">
                    <h4>WHY is the matrix [[cos(θ/2), -sin(θ/2)], [sin(θ/2), cos(θ/2)]]?</h4>
                    <p><strong>Derivation from exponential:</strong></p>
                    <div class="formula">Ry(θ) = e^(-iθY/2) = cos(θ/2)·I - i·sin(θ/2)·Y</div>
                    <p class="explanation" style="margin-top:10px;">Since Y = [[0,-i],[i,0]], we get -i·Y = [[0,-1],[1,0]]:</p>
                    <div class="matrix-visual">
                        <span style="color:#888;">Ry(θ) = </span>
                        <div class="matrix-box" style="border-color:rgba(78,205,196,0.5);">
                            <div class="cell" style="background:rgba(78,205,196,0.2);">cos(θ/2)</div><div class="cell" style="background:rgba(78,205,196,0.2);">-sin(θ/2)</div>
                            <div class="cell" style="background:rgba(78,205,196,0.2);">sin(θ/2)</div><div class="cell" style="background:rgba(78,205,196,0.2);">cos(θ/2)</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="key-insight">
                <h4>Key Insight: Ry creates real superpositions</h4>
                <p>Ry(θ)|0⟩ = cos(θ/2)|0⟩ + sin(θ/2)|1⟩. Both coefficients are REAL! This is why Ry is often used for state preparation - you can create any state on the XZ plane of the Bloch sphere.</p>
            </div>
        </div>

        <div class="gate-card rz-card">
            <h3>Rz(θ) - Rotation around Z-axis</h3>
            <div class="fourwh-box" style="margin-top:0;">
                <div class="fourwh-item what">
                    <h4>WHAT does Rz(θ) do?</h4>
                    <p>Rz(θ) rotates the state by angle θ around the Z-axis. States on the Z-axis (|0⟩, |1⟩) only get a global phase. Equatorial states rotate around the equator. Rz is a generalized phase gate!</p>
                </div>
                <div class="fourwh-item why">
                    <h4>WHY is the matrix [[e^(-iθ/2), 0], [0, e^(iθ/2)]]?</h4>
                    <p><strong>Derivation from exponential:</strong></p>
                    <div class="formula">Rz(θ) = e^(-iθZ/2) = cos(θ/2)·I - i·sin(θ/2)·Z</div>
                    <p class="explanation" style="margin-top:10px;">Since Z is diagonal, the exponential is also diagonal:</p>
                    <div class="matrix-visual">
                        <span style="color:#888;">Rz(θ) = </span>
                        <div class="matrix-box" style="border-color:rgba(255,217,61,0.5);">
                            <div class="cell" style="background:rgba(255,217,61,0.2);">e^(-iθ/2)</div><div class="cell" style="background:rgba(255,217,61,0.2);">0</div>
                            <div class="cell" style="background:rgba(255,217,61,0.2);">0</div><div class="cell" style="background:rgba(255,217,61,0.2);">e^(iθ/2)</div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="key-insight">
                <h4>Key Insight: Rz generalizes S and T</h4>
                <p>Rz(π/2) = diag(e^(-iπ/4), e^(iπ/4)) = e^(-iπ/4)·S. Rz(π/4) = e^(-iπ/8)·T. The S and T gates are just Rz at specific angles (up to global phase)!</p>
            </div>
        </div>

        <section class="section">
            <div class="relation-box">
                <h3>Relationships Between Rotation Gates</h3>
                <div class="derivation-step">
                    <h4>Connection to Pauli Gates</h4>
                    <div class="formula">Rx(π) = -iX, Ry(π) = -iY, Rz(π) = -iZ</div>
                    <p class="explanation">Pauli gates are 180° rotations (up to global phase)!</p>
                </div>
                <div class="derivation-step">
                    <h4>Connection to Phase Gates</h4>
                    <div class="formula">S = Rz(π/2) · e^(iπ/4), T = Rz(π/4) · e^(iπ/8)</div>
                </div>
                <div class="derivation-step">
                    <h4>Euler Decomposition</h4>
                    <div class="formula">Any single-qubit gate U = e^(iα) · Rz(β) · Ry(γ) · Rz(δ)</div>
                    <p class="explanation">Any unitary can be decomposed into just Rz and Ry rotations!</p>
                </div>
                <div class="derivation-step">
                    <h4>Hadamard from Rotations</h4>
                    <div class="formula">H = Ry(π/2) · Rz(π) = Rz(π) · Ry(π/2) (up to global phase)</div>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="matrix-derivation">
                <h3>Practical Applications</h3>
                <div class="derivation-step">
                    <h4>State Preparation</h4>
                    <p class="explanation">To prepare |ψ⟩ = cos(θ/2)|0⟩ + e^(iφ)sin(θ/2)|1⟩ from |0⟩:</p>
                    <div class="formula">|ψ⟩ = Rz(φ) · Ry(θ) · |0⟩</div>
                </div>
                <div class="derivation-step">
                    <h4>Variational Circuits</h4>
                    <p class="explanation">In VQE/QAOA, rotation angles are optimized classically:</p>
                    <div class="formula">U(θ₁,θ₂,...) = ∏ᵢ Ry(θᵢ) · CNOT · Rz(θⱼ) · ...</div>
                </div>
                <div class="derivation-step">
                    <h4>Quantum Fourier Transform</h4>
                    <p class="explanation">QFT uses controlled rotations Rz(π/2^k) for phase kickback.</p>
                </div>
            </div>
        </section>

        <div class="nav-buttons">
            <a href="../05-hadamard-gate/index.html" class="btn">Previous: Hadamard Gate</a>
            <a href="../07-multiple-qubit-gates/index.html" class="btn btn-primary">Next: Multiple-Qubit Gates</a>
        </div>
    </div>

    <script>
    let scene, camera, renderer, controls, stateArrow;
    let theta = 0, phi = 0;
    
    function init() {
        const container = document.getElementById('bloch-container');
        if (!container) return;
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        
        camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(3, 2.5, 3);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.4);
        dirLight.position.set(5, 5, 5);
        scene.add(dirLight);
        
        const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
        const sphereMat = new THREE.MeshPhongMaterial({ color: 0x64ffda, transparent: true, opacity: 0.12 });
        scene.add(new THREE.Mesh(sphereGeo, sphereMat));
        
        const wireGeo = new THREE.SphereGeometry(1, 16, 16);
        const wireMat = new THREE.MeshBasicMaterial({ color: 0x64ffda, wireframe: true, transparent: true, opacity: 0.15 });
        scene.add(new THREE.Mesh(wireGeo, wireMat));
        
        createAxis(new THREE.Vector3(1, 0, 0), 0xff6b6b, '+X', '-X');
        createAxis(new THREE.Vector3(0, 1, 0), 0x4ecdc4, '+Y', '-Y');
        createAxis(new THREE.Vector3(0, 0, 1), 0xffd93d, '+Z |0>', '-Z |1>');
        
        const eqGeo = new THREE.RingGeometry(0.99, 1.01, 64);
        const eqMat = new THREE.MeshBasicMaterial({ color: 0x64ffda, side: THREE.DoubleSide, transparent: true, opacity: 0.3 });
        const equator = new THREE.Mesh(eqGeo, eqMat);
        equator.rotation.x = Math.PI / 2;
        scene.add(equator);
        
        stateArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1.1, 0x64ffda, 0.15, 0.1);
        scene.add(stateArrow);
        
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        animate();
        updateDisplay();
    }
    
    function createAxis(dir, color, posLabel, negLabel) {
        scene.add(new THREE.ArrowHelper(dir, new THREE.Vector3(0,0,0), 1.5, color, 0.1, 0.06));
        scene.add(new THREE.ArrowHelper(dir.clone().negate(), new THREE.Vector3(0,0,0), 1.5, color, 0.1, 0.06));
        [0.5, 1.0].forEach(function(d) {
            var g = new THREE.SphereGeometry(0.02, 8, 8);
            var m = new THREE.MeshBasicMaterial({ color: color });
            var t1 = new THREE.Mesh(g, m); t1.position.copy(dir.clone().multiplyScalar(d)); scene.add(t1);
            var t2 = new THREE.Mesh(g, m); t2.position.copy(dir.clone().multiplyScalar(-d)); scene.add(t2);
        });
        createLabel(posLabel, dir.clone().multiplyScalar(1.7), color);
        createLabel(negLabel, dir.clone().multiplyScalar(-1.7), color);
    }
    
    function createLabel(text, pos, color) {
        var c = document.createElement('canvas'); c.width = 128; c.height = 64;
        var ctx = c.getContext('2d');
        ctx.fillStyle = '#' + color.toString(16).padStart(6, '0');
        ctx.font = 'bold 20px Arial'; ctx.textAlign = 'center';
        ctx.fillText(text, 64, 40);
        var t = new THREE.CanvasTexture(c);
        var s = new THREE.Sprite(new THREE.SpriteMaterial({ map: t, transparent: true }));
        s.position.copy(pos); s.scale.set(0.5, 0.25, 1); scene.add(s);
    }
    
    function updateAngleDisplay() {
        var deg = document.getElementById('angle-slider').value;
        var rad = deg * Math.PI / 180;
        var piStr = '';
        if (deg == 0) piStr = '0';
        else if (deg == 45) piStr = 'π/4 (45°)';
        else if (deg == 90) piStr = 'π/2 (90°)';
        else if (deg == 180) piStr = 'π (180°)';
        else if (deg == 270) piStr = '3π/2 (270°)';
        else if (deg == 360) piStr = '2π (360°)';
        else piStr = deg + '°';
        document.getElementById('angle-display').textContent = piStr;
    }
    
    function updateDisplay() {
        var td = (theta * 180 / Math.PI).toFixed(1);
        var pd = ((phi * 180 / Math.PI + 360) % 360).toFixed(1);
        document.getElementById('theta-value').textContent = td + '\u00B0';
        document.getElementById('phi-value').textContent = pd + '\u00B0';
        document.getElementById('theta-bar').style.width = (theta / Math.PI * 100) + '%';
        document.getElementById('phi-bar').style.width = (((phi + 2*Math.PI) % (2*Math.PI)) / (2*Math.PI) * 100) + '%';
        var x = Math.sin(theta) * Math.cos(phi);
        var y = Math.sin(theta) * Math.sin(phi);
        var z = Math.cos(theta);
        document.getElementById('current-coords').textContent = 'x=' + x.toFixed(2) + ', y=' + y.toFixed(2) + ', z=' + z.toFixed(2);
        var name = '';
        if (theta < 0.1) name = '|0\u27E9';
        else if (Math.abs(theta - Math.PI) < 0.1) name = '|1\u27E9';
        else if (Math.abs(theta - Math.PI/2) < 0.1) {
            var pn = ((phi % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);
            if (pn < 0.1 || pn > 2*Math.PI - 0.1) name = '|+\u27E9';
            else if (Math.abs(pn - Math.PI) < 0.1) name = '|-\u27E9';
            else if (Math.abs(pn - Math.PI/2) < 0.1) name = '|i\u27E9';
            else if (Math.abs(pn - 3*Math.PI/2) < 0.1) name = '|-i\u27E9';
            else name = 'superposition';
        } else name = 'superposition';
        document.getElementById('current-state').textContent = name;
        stateArrow.setDirection(new THREE.Vector3(x, y, z).normalize());
    }
    
    function applyRotation(axis) {
        var deg = parseFloat(document.getElementById('angle-slider').value);
        var angle = deg * Math.PI / 180;
        var x = Math.sin(theta) * Math.cos(phi);
        var y = Math.sin(theta) * Math.sin(phi);
        var z = Math.cos(theta);
        var nx, ny, nz;
        if (axis === 'X') {
            nx = x;
            ny = y * Math.cos(angle) - z * Math.sin(angle);
            nz = y * Math.sin(angle) + z * Math.cos(angle);
        } else if (axis === 'Y') {
            nx = x * Math.cos(angle) + z * Math.sin(angle);
            ny = y;
            nz = -x * Math.sin(angle) + z * Math.cos(angle);
        } else {
            nx = x * Math.cos(angle) - y * Math.sin(angle);
            ny = x * Math.sin(angle) + y * Math.cos(angle);
            nz = z;
        }
        theta = Math.acos(Math.max(-1, Math.min(1, nz)));
        phi = Math.atan2(ny, nx);
        document.getElementById('rotation-info').textContent = 'R' + axis.toLowerCase() + '(' + deg + '\u00B0)';
        updateDisplay();
    }
    
    function resetState() { theta = 0; phi = 0; document.getElementById('rotation-info').textContent = 'None yet'; updateDisplay(); }
    
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    
    window.addEventListener('load', init);
    window.addEventListener('resize', function() {
        var c = document.getElementById('bloch-container');
        if (c && renderer) { camera.aspect = c.clientWidth / c.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(c.clientWidth, c.clientHeight); }
    });
    </script>
</body>
</html>
