<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hadamard Gate - Quantum Gates Learning</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        .dual-view {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .view-panel {
            background: rgba(255,255,255,0.03);
            border-radius: 15px;
            padding: 20px;
            border: 1px solid rgba(100,255,218,0.2);
        }
        .view-panel h3 {
            text-align: center;
            color: var(--primary-color);
            margin-bottom: 15px;
        }
        .state-display {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin: 20px 0;
        }
        .state-box {
            text-align: center;
            padding: 20px;
            background: rgba(100,255,218,0.1);
            border-radius: 10px;
            min-width: 120px;
        }
        .state-box .ket {
            font-size: 2em;
            font-weight: bold;
            color: var(--primary-color);
        }
        .state-box .prob {
            font-size: 1.2em;
            margin-top: 10px;
        }
        .prob-bar {
            height: 20px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin-top: 10px;
        }
        .prob-fill {
            height: 100%;
            background: linear-gradient(90deg, #64ffda, #4ecdc4);
            transition: width 0.5s ease;
        }
        .circuit-container {
            background: #0a0a0a;
            border-radius: 15px;
            padding: 30px;
            margin: 20px 0;
            text-align: center;
        }
        .circuit-svg {
            max-width: 100%;
        }
        .animation-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }
        .anim-btn {
            padding: 12px 25px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .anim-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102,126,234,0.4);
        }
        .superposition-viz {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 30px;
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            margin: 20px 0;
        }
        .wave-container {
            width: 200px;
            height: 100px;
        }
        @media (max-width: 768px) {
            .dual-view {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Hadamard Gate</h1>
            <p class="subtitle">The Gateway to Superposition</p>
        </header>

        <section class="section">
            <h2>Overview</h2>
            <p>
                The Hadamard gate (H) is one of the most important gates in quantum computing. 
                It creates <strong>superposition</strong> - the ability for a qubit to be in multiple states simultaneously.
                This is the foundation of quantum parallelism and quantum advantage.
            </p>
            
            <div class="dual-view">
                <div class="view-panel">
                    <h3>Before Hadamard</h3>
                    <div id="before-canvas" style="height: 300px;"></div>
                    <div class="state-display">
                        <div class="state-box">
                            <div class="ket">|0⟩</div>
                            <div class="prob">100%</div>
                            <div class="prob-bar"><div class="prob-fill" style="width: 100%"></div></div>
                        </div>
                        <div class="state-box">
                            <div class="ket">|1⟩</div>
                            <div class="prob">0%</div>
                            <div class="prob-bar"><div class="prob-fill" style="width: 0%"></div></div>
                        </div>
                    </div>
                </div>
                <div class="view-panel">
                    <h3>After Hadamard</h3>
                    <div id="after-canvas" style="height: 300px;"></div>
                    <div class="state-display">
                        <div class="state-box">
                            <div class="ket">|0⟩</div>
                            <div class="prob">50%</div>
                            <div class="prob-bar"><div class="prob-fill" style="width: 50%"></div></div>
                        </div>
                        <div class="state-box">
                            <div class="ket">|1⟩</div>
                            <div class="prob">50%</div>
                            <div class="prob-bar"><div class="prob-fill" style="width: 50%"></div></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Matrix Representation</h2>
            <div class="gate-card">
                <span class="gate-symbol">H</span>
                <h3>The Hadamard Matrix</h3>
                
                <div class="matrix">
                    <p>H = 1/√2</p>
                    <div class="matrix-grid matrix-2x2">
                        <div class="matrix-cell">1</div>
                        <div class="matrix-cell">1</div>
                        <div class="matrix-cell">1</div>
                        <div class="matrix-cell">-1</div>
                    </div>
                </div>
                
                <div class="formula">
                    H = (X + Z) / √2
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Interactive Visualization</h2>
            <p>Watch the Hadamard gate transform states on the Bloch sphere:</p>
            
            <div id="main-canvas" style="height: 500px; border-radius: 15px; overflow: hidden;"></div>
            
            <div class="animation-controls">
                <button class="anim-btn" onclick="applyHadamard()">Apply H Gate</button>
                <button class="anim-btn" onclick="resetState()">Reset to |0⟩</button>
                <button class="anim-btn" onclick="toggleAnimation()">Toggle Animation</button>
            </div>
            
            <div id="current-state" class="key-point" style="text-align: center;">
                <h3>Current State</h3>
                <p id="state-text" style="font-size: 1.5em;">|ψ⟩ = |0⟩</p>
            </div>
        </section>

        <section class="section">
            <h2>Action on Basis States</h2>
            
            <div class="superposition-viz">
                <div style="text-align: center;">
                    <div style="font-size: 2em; color: #4ecdc4;">|0⟩</div>
                    <div style="font-size: 0.9em; opacity: 0.7;">North Pole</div>
                </div>
                <div style="font-size: 3em; color: #ffd93d;">→ H →</div>
                <div style="text-align: center;">
                    <div style="font-size: 2em; color: #64ffda;">|+⟩ = (|0⟩ + |1⟩)/√2</div>
                    <div style="font-size: 0.9em; opacity: 0.7;">Equator (+X)</div>
                </div>
            </div>
            
            <div class="superposition-viz">
                <div style="text-align: center;">
                    <div style="font-size: 2em; color: #ff6b6b;">|1⟩</div>
                    <div style="font-size: 0.9em; opacity: 0.7;">South Pole</div>
                </div>
                <div style="font-size: 3em; color: #ffd93d;">→ H →</div>
                <div style="text-align: center;">
                    <div style="font-size: 2em; color: #64ffda;">|-⟩ = (|0⟩ - |1⟩)/√2</div>
                    <div style="font-size: 0.9em; opacity: 0.7;">Equator (-X)</div>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Circuit Representation</h2>
            <div class="circuit-container">
                <svg class="circuit-svg" width="400" height="100" viewBox="0 0 400 100">
                    <!-- Wire -->
                    <line x1="50" y1="50" x2="350" y2="50" stroke="#64ffda" stroke-width="2"/>
                    
                    <!-- Input label -->
                    <text x="30" y="55" fill="#64ffda" font-size="16" font-family="monospace">|0⟩</text>
                    
                    <!-- Hadamard gate -->
                    <rect x="150" y="25" width="50" height="50" rx="8" fill="url(#hGradient)" stroke="#64ffda" stroke-width="2"/>
                    <text x="175" y="57" fill="white" font-size="20" font-weight="bold" text-anchor="middle">H</text>
                    
                    <!-- Output label -->
                    <text x="320" y="55" fill="#64ffda" font-size="16" font-family="monospace">|+⟩</text>
                    
                    <!-- Gradient definition -->
                    <defs>
                        <linearGradient id="hGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                            <stop offset="0%" style="stop-color:#667eea"/>
                            <stop offset="100%" style="stop-color:#764ba2"/>
                        </linearGradient>
                    </defs>
                </svg>
            </div>
        </section>

        <section class="section">
            <h2>Key Properties</h2>
            
            <div class="concept-grid">
                <div class="gate-card">
                    <h3>Self-Inverse</h3>
                    <div class="formula">H² = I</div>
                    <p>Applying Hadamard twice returns to the original state.</p>
                </div>
                
                <div class="gate-card">
                    <h3>Hermitian</h3>
                    <div class="formula">H† = H</div>
                    <p>The Hadamard gate equals its own conjugate transpose.</p>
                </div>
                
                <div class="gate-card">
                    <h3>Basis Change</h3>
                    <div class="formula">HXH = Z, HZH = X</div>
                    <p>Hadamard swaps the X and Z bases.</p>
                </div>
                
                <div class="gate-card">
                    <h3>Bloch Rotation</h3>
                    <div class="formula">π rotation about (X+Z)/√2</div>
                    <p>Rotates the Bloch sphere about the diagonal axis.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Superposition Explained</h2>
            <div class="highlight">
                <h3>What is Superposition?</h3>
                <p>
                    When a qubit is in superposition, it exists in a combination of |0⟩ and |1⟩ simultaneously.
                    This is NOT the same as being "half 0 and half 1" - the qubit genuinely exists in both states
                    until measured.
                </p>
                <p>
                    The state |+⟩ = (|0⟩ + |1⟩)/√2 has:
                </p>
                <ul>
                    <li>50% probability of measuring |0⟩</li>
                    <li>50% probability of measuring |1⟩</li>
                    <li>Positive relative phase between components</li>
                </ul>
            </div>
            
            <div class="example">
                <h3>Quantum Parallelism</h3>
                <p>
                    With n qubits in superposition, we can represent 2ⁿ states simultaneously:
                </p>
                <ul>
                    <li>1 qubit: 2 states</li>
                    <li>10 qubits: 1,024 states</li>
                    <li>50 qubits: ~10¹⁵ states</li>
                    <li>300 qubits: More states than atoms in the universe!</li>
                </ul>
            </div>
        </section>

        <div class="nav-buttons">
            <a href="../04-identity-phase-gates/index.html" class="btn">Previous: Identity & Phase Gates</a>
            <a href="../06-rotation-gates/index.html" class="btn btn-primary">Next: Rotation Gates</a>
        </div>
    </div>

    <script>
        // Main interactive Bloch sphere
        const mainContainer = document.getElementById('main-canvas');
        const mainScene = new THREE.Scene();
        mainScene.background = new THREE.Color(0x0a0a0a);
        
        const mainCamera = new THREE.PerspectiveCamera(75, mainContainer.clientWidth / 500, 0.1, 1000);
        mainCamera.position.set(2.5, 2, 2.5);
        
        const mainRenderer = new THREE.WebGLRenderer({ antialias: true });
        mainRenderer.setSize(mainContainer.clientWidth, 500);
        mainContainer.appendChild(mainRenderer.domElement);
        
        const mainControls = new THREE.OrbitControls(mainCamera, mainRenderer.domElement);
        mainControls.enableDamping = true;
        
        // Lights
        mainScene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const light = new THREE.PointLight(0xffffff, 0.8);
        light.position.set(10, 10, 10);
        mainScene.add(light);
        
        // Bloch sphere
        const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
        const sphereMat = new THREE.MeshPhongMaterial({ color: 0x64ffda, transparent: true, opacity: 0.15 });
        mainScene.add(new THREE.Mesh(sphereGeo, sphereMat));
        
        const wireGeo = new THREE.SphereGeometry(1, 16, 16);
        const wireMat = new THREE.MeshBasicMaterial({ color: 0x64ffda, wireframe: true, transparent: true, opacity: 0.2 });
        mainScene.add(new THREE.Mesh(wireGeo, wireMat));
        
        // Axes
        const axisLen = 1.4;
        mainScene.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), axisLen, 0xff6b6b, 0.1, 0.05));
        mainScene.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), axisLen, 0x4ecdc4, 0.1, 0.05));
        mainScene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), axisLen, 0xffd93d, 0.1, 0.05));
        
        // Hadamard rotation axis (X+Z)/sqrt(2)
        const hAxis = new THREE.Vector3(1, 0, 1).normalize();
        const hAxisArrow = new THREE.ArrowHelper(hAxis, new THREE.Vector3(0,0,0), 1.2, 0x764ba2, 0.1, 0.05);
        mainScene.add(hAxisArrow);
        
        // Rotation ring around H axis
        const hRingGeo = new THREE.TorusGeometry(0.7, 0.02, 16, 100);
        const hRingMat = new THREE.MeshBasicMaterial({ color: 0x764ba2, transparent: true, opacity: 0.5 });
        const hRing = new THREE.Mesh(hRingGeo, hRingMat);
        // Rotate ring to be perpendicular to H axis
        hRing.lookAt(hAxis);
        mainScene.add(hRing);
        
        // State vector
        let currentTheta = 0;
        let currentPhi = 0;
        let targetTheta = 0;
        let targetPhi = 0;
        let animating = false;
        
        const stateArrow = new THREE.ArrowHelper(
            new THREE.Vector3(0, 0, 1),
            new THREE.Vector3(0, 0, 0),
            1, 0xff6b6b, 0.15, 0.1
        );
        mainScene.add(stateArrow);
        
        // Trail points
        const trailPoints = [];
        const trailGeometry = new THREE.BufferGeometry();
        const trailMaterial = new THREE.PointsMaterial({ color: 0xffd93d, size: 0.03 });
        const trail = new THREE.Points(trailGeometry, trailMaterial);
        mainScene.add(trail);
        
        function updateStateVector() {
            const x = Math.sin(currentTheta) * Math.cos(currentPhi);
            const y = Math.sin(currentTheta) * Math.sin(currentPhi);
            const z = Math.cos(currentTheta);
            stateArrow.setDirection(new THREE.Vector3(x, y, z).normalize());
            
            // Add trail point
            if (animating) {
                trailPoints.push(x, y, z);
                if (trailPoints.length > 300) {
                    trailPoints.splice(0, 3);
                }
                trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute(trailPoints, 3));
            }
        }
        
        function applyHadamard() {
            if (animating) return;
            animating = true;
            
            // Clear trail
            trailPoints.length = 0;
            
            const startTheta = currentTheta;
            const startPhi = currentPhi;
            
            // Calculate target state after Hadamard
            // H|0⟩ = |+⟩ (theta=π/2, phi=0)
            // H|+⟩ = |0⟩ (theta=0, phi=0)
            // H|1⟩ = |-⟩ (theta=π/2, phi=π)
            // H|-⟩ = |1⟩ (theta=π, phi=0)
            
            if (Math.abs(currentTheta) < 0.1) {
                // |0⟩ -> |+⟩
                targetTheta = Math.PI / 2;
                targetPhi = 0;
                document.getElementById('state-text').textContent = '|ψ⟩ = |+⟩ = (|0⟩ + |1⟩)/√2';
            } else if (Math.abs(currentTheta - Math.PI/2) < 0.1 && Math.abs(currentPhi) < 0.1) {
                // |+⟩ -> |0⟩
                targetTheta = 0;
                targetPhi = 0;
                document.getElementById('state-text').textContent = '|ψ⟩ = |0⟩';
            } else if (Math.abs(currentTheta - Math.PI) < 0.1) {
                // |1⟩ -> |-⟩
                targetTheta = Math.PI / 2;
                targetPhi = Math.PI;
                document.getElementById('state-text').textContent = '|ψ⟩ = |-⟩ = (|0⟩ - |1⟩)/√2';
            } else if (Math.abs(currentTheta - Math.PI/2) < 0.1 && Math.abs(currentPhi - Math.PI) < 0.1) {
                // |-⟩ -> |1⟩
                targetTheta = Math.PI;
                targetPhi = 0;
                document.getElementById('state-text').textContent = '|ψ⟩ = |1⟩';
            } else {
                // General case - just toggle
                targetTheta = Math.PI / 2;
                targetPhi = 0;
                document.getElementById('state-text').textContent = '|ψ⟩ = |+⟩';
            }
            
            const duration = 1500;
            const startTime = Date.now();
            
            function animateTransition() {
                const elapsed = Date.now() - startTime;
                const t = Math.min(elapsed / duration, 1);
                const easeT = 1 - Math.pow(1 - t, 3);
                
                currentTheta = startTheta + (targetTheta - startTheta) * easeT;
                currentPhi = startPhi + (targetPhi - startPhi) * easeT;
                
                updateStateVector();
                
                if (t < 1) {
                    requestAnimationFrame(animateTransition);
                } else {
                    animating = false;
                }
            }
            
            animateTransition();
        }
        
        function resetState() {
            currentTheta = 0;
            currentPhi = 0;
            trailPoints.length = 0;
            trailGeometry.setAttribute('position', new THREE.Float32BufferAttribute([], 3));
            updateStateVector();
            document.getElementById('state-text').textContent = '|ψ⟩ = |0⟩';
        }
        
        let autoAnimate = false;
        function toggleAnimation() {
            autoAnimate = !autoAnimate;
        }
        
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            if (autoAnimate && !animating) {
                currentPhi = time;
                updateStateVector();
            }
            
            // Rotate H ring
            hRing.rotation.z = time * 0.5;
            
            mainControls.update();
            mainRenderer.render(mainScene, mainCamera);
        }
        animate();
        
        // Before/After mini visualizations
        function createMiniBloch(containerId, theta, phi, color) {
            const container = document.getElementById(containerId);
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            const camera = new THREE.PerspectiveCamera(75, container.clientWidth / 300, 0.1, 1000);
            camera.position.set(2, 1.5, 2);
            
            const renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, 300);
            container.appendChild(renderer.domElement);
            
            const controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            
            // Sphere
            scene.add(new THREE.Mesh(
                new THREE.SphereGeometry(1, 32, 32),
                new THREE.MeshBasicMaterial({ color: 0x64ffda, wireframe: true, transparent: true, opacity: 0.2 })
            ));
            
            // Axes
            scene.add(new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1.2, 0xff6b6b, 0.08, 0.04));
            scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,0), 1.2, 0x4ecdc4, 0.08, 0.04));
            scene.add(new THREE.ArrowHelper(new THREE.Vector3(0,0,1), new THREE.Vector3(0,0,0), 1.2, 0xffd93d, 0.08, 0.04));
            
            // State vector
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(theta);
            scene.add(new THREE.ArrowHelper(
                new THREE.Vector3(x, y, z).normalize(),
                new THREE.Vector3(0, 0, 0),
                1, color, 0.12, 0.08
            ));
            
            function animateMini() {
                requestAnimationFrame(animateMini);
                controls.update();
                renderer.render(scene, camera);
            }
            animateMini();
        }
        
        createMiniBloch('before-canvas', 0, 0, 0x4ecdc4);  // |0⟩
        createMiniBloch('after-canvas', Math.PI/2, 0, 0xff6b6b);  // |+⟩
        
        window.addEventListener('resize', () => {
            mainCamera.aspect = mainContainer.clientWidth / 500;
            mainCamera.updateProjectionMatrix();
            mainRenderer.setSize(mainContainer.clientWidth, 500);
        });
    </script>
</body>
</html>
