<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bloch Sphere Visualization - Quantum Gates Learning</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        .bloch-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin: 30px 0;
        }
        .bloch-panel {
            background: rgba(0,0,0,0.3);
            border-radius: 15px;
            padding: 20px;
            min-height: 400px;
        }
        #bloch-canvas {
            width: 100%;
            height: 350px;
            border-radius: 10px;
        }
        .state-info {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin-top: 15px;
        }
        .state-info h4 {
            color: var(--primary-color);
            margin-bottom: 10px;
        }
        .coordinate-display {
            font-family: monospace;
            font-size: 1.1em;
        }
        .gate-buttons {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 20px 0;
        }
        .gate-btn {
            padding: 12px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border: none;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .gate-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 20px rgba(102,126,234,0.4);
        }
        .special-states {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        .state-card {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .state-card:hover {
            background: rgba(100,255,218,0.1);
            transform: translateY(-3px);
        }
        .state-card h4 {
            color: var(--primary-color);
            margin-bottom: 5px;
        }
        .bloch-explanation {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 20px;
            margin: 30px 0;
        }
        .axis-card {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 20px;
            text-align: center;
        }
        .axis-card h3 {
            margin-bottom: 10px;
        }
        .axis-card.x-axis h3 { color: #ff6b6b; }
        .axis-card.y-axis h3 { color: #4ecdc4; }
        .axis-card.z-axis h3 { color: #ffd93d; }
        @media (max-width: 768px) {
            .bloch-container {
                grid-template-columns: 1fr;
            }
            .gate-buttons {
                grid-template-columns: repeat(2, 1fr);
            }
            .special-states, .bloch-explanation {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Bloch Sphere Visualization</h1>
            <p class="subtitle">Geometric View of Single-Qubit States and Gates</p>
        </header>

        <section class="section">
            <h2>The Bloch Sphere</h2>
            <p>
                The <strong>Bloch sphere</strong> is a geometric representation of a single qubit's state. 
                Any pure state |ψ⟩ = cos(θ/2)|0⟩ + e^(iφ)sin(θ/2)|1⟩ corresponds to a point on the unit sphere.
            </p>
        </section>

        <section class="section">
            <h2>Interactive Bloch Sphere</h2>
            
            <div class="bloch-container">
                <div class="bloch-panel">
                    <div id="bloch-canvas"></div>
                    <div class="state-info">
                        <h4>Current State</h4>
                        <div class="coordinate-display">
                            <div>|ψ⟩ = <span id="state-ket">|0⟩</span></div>
                            <div>θ = <span id="theta-val">0</span>°, φ = <span id="phi-val">0</span>°</div>
                            <div>(x, y, z) = (<span id="x-val">0</span>, <span id="y-val">0</span>, <span id="z-val">1</span>)</div>
                        </div>
                    </div>
                </div>
                
                <div class="bloch-panel">
                    <h3>Apply Gates</h3>
                    <div class="gate-buttons">
                        <button class="gate-btn" onclick="applyGate('X')">X</button>
                        <button class="gate-btn" onclick="applyGate('Y')">Y</button>
                        <button class="gate-btn" onclick="applyGate('Z')">Z</button>
                        <button class="gate-btn" onclick="applyGate('H')">H</button>
                        <button class="gate-btn" onclick="applyGate('S')">S</button>
                        <button class="gate-btn" onclick="applyGate('T')">T</button>
                        <button class="gate-btn" onclick="applyGate('Rx')">Rx(π/4)</button>
                        <button class="gate-btn" onclick="applyGate('Ry')">Ry(π/4)</button>
                    </div>
                    
                    <h3>Special States</h3>
                    <div class="special-states">
                        <div class="state-card" onclick="setState('0')">
                            <h4>|0⟩</h4>
                            <p>North pole</p>
                        </div>
                        <div class="state-card" onclick="setState('1')">
                            <h4>|1⟩</h4>
                            <p>South pole</p>
                        </div>
                        <div class="state-card" onclick="setState('+')">
                            <h4>|+⟩</h4>
                            <p>+X axis</p>
                        </div>
                        <div class="state-card" onclick="setState('-')">
                            <h4>|-⟩</h4>
                            <p>-X axis</p>
                        </div>
                        <div class="state-card" onclick="setState('+i')">
                            <h4>|+i⟩</h4>
                            <p>+Y axis</p>
                        </div>
                        <div class="state-card" onclick="setState('-i')">
                            <h4>|-i⟩</h4>
                            <p>-Y axis</p>
                        </div>
                    </div>
                    
                    <button class="gate-btn" style="width: 100%; margin-top: 15px; background: linear-gradient(135deg, #ff6b6b, #ff8e8e);" onclick="resetState()">Reset to |0⟩</button>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Understanding the Axes</h2>
            
            <div class="bloch-explanation">
                <div class="axis-card x-axis">
                    <h3>X-Axis</h3>
                    <p><strong>+X:</strong> |+⟩ = (|0⟩+|1⟩)/√2</p>
                    <p><strong>-X:</strong> |-⟩ = (|0⟩-|1⟩)/√2</p>
                    <p>Eigenstates of Pauli-X</p>
                </div>
                
                <div class="axis-card y-axis">
                    <h3>Y-Axis</h3>
                    <p><strong>+Y:</strong> |+i⟩ = (|0⟩+i|1⟩)/√2</p>
                    <p><strong>-Y:</strong> |-i⟩ = (|0⟩-i|1⟩)/√2</p>
                    <p>Eigenstates of Pauli-Y</p>
                </div>
                
                <div class="axis-card z-axis">
                    <h3>Z-Axis</h3>
                    <p><strong>+Z:</strong> |0⟩ (North pole)</p>
                    <p><strong>-Z:</strong> |1⟩ (South pole)</p>
                    <p>Eigenstates of Pauli-Z</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Gates as Rotations</h2>
            
            <div class="concept-grid">
                <div class="gate-card">
                    <h3>X Gate</h3>
                    <div class="formula">π rotation around X</div>
                    <p>Flips |0⟩ ↔ |1⟩ (bit flip)</p>
                </div>
                
                <div class="gate-card">
                    <h3>Y Gate</h3>
                    <div class="formula">π rotation around Y</div>
                    <p>Combines bit and phase flip</p>
                </div>
                
                <div class="gate-card">
                    <h3>Z Gate</h3>
                    <div class="formula">π rotation around Z</div>
                    <p>Phase flip: |1⟩ → -|1⟩</p>
                </div>
                
                <div class="gate-card">
                    <h3>H Gate</h3>
                    <div class="formula">π around (X+Z)/√2</div>
                    <p>Creates superposition</p>
                </div>
                
                <div class="gate-card">
                    <h3>S Gate</h3>
                    <div class="formula">π/2 rotation around Z</div>
                    <p>Quarter turn in XY plane</p>
                </div>
                
                <div class="gate-card">
                    <h3>T Gate</h3>
                    <div class="formula">π/4 rotation around Z</div>
                    <p>Eighth turn in XY plane</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Key Insights</h2>
            
            <div class="highlight">
                <ul>
                    <li><strong>Antipodal points</strong> represent orthogonal states</li>
                    <li><strong>Great circles</strong> through a point show all states reachable by rotation around one axis</li>
                    <li><strong>Global phase</strong> doesn't change the point on the sphere</li>
                    <li><strong>Mixed states</strong> are inside the sphere (not on the surface)</li>
                </ul>
            </div>
        </section>

        <div class="nav-buttons">
            <a href="../12-gate-decomposition/index.html" class="btn">Previous: Gate Decomposition</a>
            <a href="../14-entanglement-creation/index.html" class="btn btn-primary">Next: Entanglement</a>
        </div>
    </div>

    <script>
        let scene, camera, renderer, sphere, stateVector, stateArrow;
        let theta = 0, phi = 0;
        
        function init() {
            const container = document.getElementById('bloch-canvas');
            const width = container.clientWidth;
            const height = 350;
            
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x0a0a0a);
            
            camera = new THREE.PerspectiveCamera(45, width / height, 0.1, 1000);
            camera.position.set(3, 2, 3);
            camera.lookAt(0, 0, 0);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(width, height);
            container.appendChild(renderer.domElement);
            
            // Sphere wireframe
            const sphereGeom = new THREE.SphereGeometry(1, 32, 32);
            const sphereMat = new THREE.MeshBasicMaterial({
                color: 0x64ffda,
                wireframe: true,
                transparent: true,
                opacity: 0.2
            });
            sphere = new THREE.Mesh(sphereGeom, sphereMat);
            scene.add(sphere);
            
            // Axes
            const axisLength = 1.5;
            const xAxis = createAxis(new THREE.Vector3(axisLength, 0, 0), 0xff6b6b);
            const yAxis = createAxis(new THREE.Vector3(0, axisLength, 0), 0x4ecdc4);
            const zAxis = createAxis(new THREE.Vector3(0, 0, axisLength), 0xffd93d);
            scene.add(xAxis);
            scene.add(yAxis);
            scene.add(zAxis);
            
            // Axis labels
            addLabel('X', 1.7, 0, 0, 0xff6b6b);
            addLabel('Y', 0, 1.7, 0, 0x4ecdc4);
            addLabel('Z', 0, 0, 1.7, 0xffd93d);
            addLabel('|0⟩', 0.3, 0, 1.4, 0xffd93d);
            addLabel('|1⟩', 0.3, 0, -1.4, 0xffd93d);
            
            // State vector
            createStateVector();
            
            // Equator circle
            const equatorGeom = new THREE.RingGeometry(0.99, 1.01, 64);
            const equatorMat = new THREE.MeshBasicMaterial({
                color: 0xffffff,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            const equator = new THREE.Mesh(equatorGeom, equatorMat);
            equator.rotation.x = Math.PI / 2;
            scene.add(equator);
            
            animate();
        }
        
        function createAxis(end, color) {
            const points = [new THREE.Vector3(0, 0, 0), end];
            const geometry = new THREE.BufferGeometry().setFromPoints(points);
            const material = new THREE.LineBasicMaterial({ color: color });
            return new THREE.Line(geometry, material);
        }
        
        function addLabel(text, x, y, z, color) {
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            canvas.width = 64;
            canvas.height = 64;
            context.fillStyle = '#' + color.toString(16).padStart(6, '0');
            context.font = 'bold 40px Arial';
            context.textAlign = 'center';
            context.fillText(text, 32, 45);
            
            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({ map: texture });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.position.set(x, y, z);
            sprite.scale.set(0.5, 0.5, 1);
            scene.add(sprite);
        }
        
        function createStateVector() {
            if (stateArrow) scene.remove(stateArrow);
            
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(theta);
            
            const dir = new THREE.Vector3(x, y, z);
            const origin = new THREE.Vector3(0, 0, 0);
            const length = 1;
            const color = 0x64ffda;
            
            stateArrow = new THREE.ArrowHelper(dir, origin, length, color, 0.15, 0.1);
            scene.add(stateArrow);
            
            // Add point at tip
            const pointGeom = new THREE.SphereGeometry(0.08, 16, 16);
            const pointMat = new THREE.MeshBasicMaterial({ color: 0xff6b6b });
            const point = new THREE.Mesh(pointGeom, pointMat);
            point.position.set(x, y, z);
            stateArrow.add(point);
            
            updateDisplay();
        }
        
        function updateDisplay() {
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(theta);
            
            document.getElementById('theta-val').textContent = (theta * 180 / Math.PI).toFixed(1);
            document.getElementById('phi-val').textContent = (phi * 180 / Math.PI).toFixed(1);
            document.getElementById('x-val').textContent = x.toFixed(3);
            document.getElementById('y-val').textContent = y.toFixed(3);
            document.getElementById('z-val').textContent = z.toFixed(3);
            
            // Update state ket
            const alpha = Math.cos(theta / 2);
            const beta = Math.sin(theta / 2);
            let ket = '';
            if (Math.abs(alpha) > 0.01) {
                ket += alpha.toFixed(2) + '|0⟩';
            }
            if (Math.abs(beta) > 0.01) {
                const phaseStr = phi === 0 ? '' : `e^(i${(phi * 180 / Math.PI).toFixed(0)}°)`;
                ket += (ket ? ' + ' : '') + phaseStr + beta.toFixed(2) + '|1⟩';
            }
            document.getElementById('state-ket').textContent = ket || '|0⟩';
        }
        
        function applyGate(gate) {
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(theta);
            
            let newX, newY, newZ;
            
            switch(gate) {
                case 'X':
                    newX = x; newY = -y; newZ = -z;
                    break;
                case 'Y':
                    newX = -x; newY = y; newZ = -z;
                    break;
                case 'Z':
                    newX = -x; newY = -y; newZ = z;
                    break;
                case 'H':
                    newX = z; newY = -y; newZ = x;
                    break;
                case 'S':
                    const sAngle = Math.PI / 2;
                    newX = x * Math.cos(sAngle) - y * Math.sin(sAngle);
                    newY = x * Math.sin(sAngle) + y * Math.cos(sAngle);
                    newZ = z;
                    break;
                case 'T':
                    const tAngle = Math.PI / 4;
                    newX = x * Math.cos(tAngle) - y * Math.sin(tAngle);
                    newY = x * Math.sin(tAngle) + y * Math.cos(tAngle);
                    newZ = z;
                    break;
                case 'Rx':
                    const rxAngle = Math.PI / 4;
                    newX = x;
                    newY = y * Math.cos(rxAngle) - z * Math.sin(rxAngle);
                    newZ = y * Math.sin(rxAngle) + z * Math.cos(rxAngle);
                    break;
                case 'Ry':
                    const ryAngle = Math.PI / 4;
                    newX = x * Math.cos(ryAngle) + z * Math.sin(ryAngle);
                    newY = y;
                    newZ = -x * Math.sin(ryAngle) + z * Math.cos(ryAngle);
                    break;
                default:
                    return;
            }
            
            theta = Math.acos(Math.max(-1, Math.min(1, newZ)));
            phi = Math.atan2(newY, newX);
            
            createStateVector();
        }
        
        function setState(state) {
            switch(state) {
                case '0':
                    theta = 0; phi = 0;
                    break;
                case '1':
                    theta = Math.PI; phi = 0;
                    break;
                case '+':
                    theta = Math.PI / 2; phi = 0;
                    break;
                case '-':
                    theta = Math.PI / 2; phi = Math.PI;
                    break;
                case '+i':
                    theta = Math.PI / 2; phi = Math.PI / 2;
                    break;
                case '-i':
                    theta = Math.PI / 2; phi = -Math.PI / 2;
                    break;
            }
            createStateVector();
        }
        
        function resetState() {
            theta = 0;
            phi = 0;
            createStateVector();
        }
        
        function animate() {
            requestAnimationFrame(animate);
            sphere.rotation.y += 0.002;
            renderer.render(scene, camera);
        }
        
        window.addEventListener('load', init);
        window.addEventListener('resize', () => {
            const container = document.getElementById('bloch-canvas');
            const width = container.clientWidth;
            camera.aspect = width / 350;
            camera.updateProjectionMatrix();
            renderer.setSize(width, 350);
        });
    </script>
</body>
</html>
