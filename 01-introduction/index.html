<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Introduction to Quantum Gates</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Introduction to Quantum Gates</h1>
            <p class="subtitle">Building Blocks of Quantum Computation</p>
        </header>

        <section class="section">
            <h2>What are Quantum Gates?</h2>
            <p>
                Quantum gates are the building blocks of quantum computation - they manipulate qubit states 
                in a way analogous to how logic gates act on classical bits. However, quantum gates differ 
                fundamentally in that they are <strong>unitary operations</strong> on complex vector spaces.
            </p>
            
            <div id="canvas-container"></div>
            
            <div class="key-point">
                <h3>Key Definition</h3>
                <p>
                    A quantum gate transforms a qubit state |ψ⟩ according to:
                </p>
                <div class="formula">
                    |ψ'⟩ = U|ψ⟩
                </div>
                <p>
                    where U is a <strong>unitary matrix</strong> satisfying:
                </p>
                <div class="formula">
                    U†U = UU† = I
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Why Unitary?</h2>
            <p>
                The unitarity condition ensures that <strong>probability is preserved</strong>. For any quantum state:
            </p>
            <div class="formula">
                |α|² + |β|² = 1
            </div>
            <p>
                This normalization must remain constant after applying any quantum gate. Unitary operations 
                guarantee this property, making them the only valid quantum operations (aside from measurement).
            </p>
            
            <div class="highlight">
                <h3>Classical vs Quantum Gates</h3>
                <table class="gate-table">
                    <tr>
                        <th>Property</th>
                        <th>Classical Gates</th>
                        <th>Quantum Gates</th>
                    </tr>
                    <tr>
                        <td>Reversibility</td>
                        <td>Often irreversible (AND, OR)</td>
                        <td>Always reversible</td>
                    </tr>
                    <tr>
                        <td>Information</td>
                        <td>Can lose information</td>
                        <td>Preserves information</td>
                    </tr>
                    <tr>
                        <td>Representation</td>
                        <td>Truth tables</td>
                        <td>Unitary matrices</td>
                    </tr>
                    <tr>
                        <td>State Space</td>
                        <td>Discrete (0 or 1)</td>
                        <td>Continuous (Bloch sphere)</td>
                    </tr>
                </table>
            </div>
        </section>

        <section class="section">
            <h2>Gate Representation</h2>
            <p>
                Quantum gates are represented as matrices that act on state vectors. For a single qubit:
            </p>
            
            <div class="example">
                <h3>State Vector</h3>
                <p>A qubit state is a 2D complex vector:</p>
                <div class="formula">
                    |ψ⟩ = α|0⟩ + β|1⟩ = [α, β]ᵀ
                </div>
            </div>
            
            <div class="example">
                <h3>Gate Matrix</h3>
                <p>A single-qubit gate is a 2×2 unitary matrix:</p>
                <div class="matrix">
                    <div class="matrix-grid matrix-2x2">
                        <div class="matrix-cell">u₀₀</div>
                        <div class="matrix-cell">u₀₁</div>
                        <div class="matrix-cell">u₁₀</div>
                        <div class="matrix-cell">u₁₁</div>
                    </div>
                </div>
            </div>
            
            <div class="example">
                <h3>Gate Action</h3>
                <p>The gate transforms the state by matrix multiplication:</p>
                <div class="formula">
                    |ψ'⟩ = U|ψ⟩ = [u₀₀α + u₀₁β, u₁₀α + u₁₁β]ᵀ
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Geometric Interpretation</h2>
            <p>
                On the <strong>Bloch sphere</strong>, any single-qubit gate corresponds to a rotation. 
                The state vector (pointing from the center to the surface) is rotated by the gate operation.
            </p>
            
            <div class="key-point">
                <h3>Bloch Sphere Facts</h3>
                <ul>
                    <li>North pole: |0⟩ state</li>
                    <li>South pole: |1⟩ state</li>
                    <li>Equator: Equal superposition states</li>
                    <li>Any gate = rotation about some axis</li>
                </ul>
            </div>
        </section>

        <section class="section">
            <h2>Types of Quantum Gates</h2>
            <div class="concept-grid">
                <div class="concept-card">
                    <h3>Single-Qubit Gates</h3>
                    <p>Act on one qubit: Pauli (X, Y, Z), Hadamard (H), Phase (S, T), Rotations (Rx, Ry, Rz)</p>
                </div>
                <div class="concept-card">
                    <h3>Two-Qubit Gates</h3>
                    <p>Act on two qubits: CNOT, CZ, SWAP</p>
                </div>
                <div class="concept-card">
                    <h3>Three-Qubit Gates</h3>
                    <p>Act on three qubits: Toffoli (CCNOT), Fredkin (CSWAP)</p>
                </div>
                <div class="concept-card">
                    <h3>Controlled Gates</h3>
                    <p>Conditional operations based on control qubit state</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Course Overview</h2>
            <p>In this course, you will learn:</p>
            <ol>
                <li><strong>Single-qubit gates:</strong> The fundamental building blocks</li>
                <li><strong>Multi-qubit gates:</strong> Operations on multiple qubits</li>
                <li><strong>Controlled gates:</strong> Conditional quantum operations</li>
                <li><strong>Universal gate sets:</strong> How to build any quantum operation</li>
                <li><strong>Gate decomposition:</strong> Breaking down complex operations</li>
                <li><strong>Practical applications:</strong> Creating entanglement and quantum circuits</li>
            </ol>
        </section>

        <div class="nav-buttons">
            <a href="../index.html" class="btn">Home</a>
            <a href="../02-single-qubit-gates/index.html" class="btn btn-primary">Next: Single-Qubit Gates</a>
        </div>
    </div>

    <script>
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a0a);
        
        const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(2.5, 2, 2.5);
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 0.8);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);
        
        // Bloch sphere
        const sphereGeometry = new THREE.SphereGeometry(1, 32, 32);
        const sphereMaterial = new THREE.MeshPhongMaterial({
            color: 0x64ffda,
            transparent: true,
            opacity: 0.15
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        scene.add(sphere);
        
        const wireframeGeometry = new THREE.SphereGeometry(1, 16, 16);
        const wireframeMaterial = new THREE.MeshBasicMaterial({
            color: 0x64ffda,
            wireframe: true,
            transparent: true,
            opacity: 0.2
        });
        const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);
        scene.add(wireframe);
        
        // Axes
        const axisLength = 1.3;
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), new THREE.Vector3(0, 0, 0), axisLength, 0xff6b6b, 0.1, 0.05));
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, 0, 0), axisLength, 0x4ecdc4, 0.1, 0.05));
        scene.add(new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), axisLength, 0xffd93d, 0.1, 0.05));
        
        // Initial state |0⟩
        const initialState = new THREE.ArrowHelper(
            new THREE.Vector3(0, 0, 1).normalize(),
            new THREE.Vector3(0, 0, 0),
            1, 0x4ecdc4, 0.15, 0.1
        );
        scene.add(initialState);
        
        // Transformed state
        const transformedState = new THREE.ArrowHelper(
            new THREE.Vector3(1, 0, 0).normalize(),
            new THREE.Vector3(0, 0, 0),
            1, 0xff6b6b, 0.15, 0.1
        );
        scene.add(transformedState);
        
        // Gate visualization ring
        const ringGeometry = new THREE.TorusGeometry(0.5, 0.02, 16, 100);
        const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xffd93d, transparent: true, opacity: 0.6 });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        scene.add(ring);
        
        let time = 0;
        function animate() {
            requestAnimationFrame(animate);
            time += 0.01;
            
            // Animate transformed state (showing gate action)
            const theta = Math.PI / 2;
            const phi = time;
            const x = Math.sin(theta) * Math.cos(phi);
            const y = Math.sin(theta) * Math.sin(phi);
            const z = Math.cos(theta);
            transformedState.setDirection(new THREE.Vector3(x, y, z).normalize());
            
            // Rotate ring
            ring.rotation.x = Math.PI / 2;
            ring.rotation.z = time;
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();
        
        window.addEventListener('resize', () => {
            camera.aspect = container.clientWidth / container.clientHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    </script>
</body>
</html>
