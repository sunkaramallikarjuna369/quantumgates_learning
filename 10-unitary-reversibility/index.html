<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Unitary Operations & Reversibility - Devin's Teaching Style</title>
    <link rel="stylesheet" href="../shared/styles.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        .fourwh-box { background: linear-gradient(135deg, rgba(100,255,218,0.12), rgba(78,205,196,0.06)); border: 2px solid rgba(100,255,218,0.4); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .fourwh-box h3 { color: #64ffda; margin-bottom: 20px; font-size: 1.4em; }
        .fourwh-item { background: rgba(0,0,0,0.4); border-radius: 12px; padding: 20px; margin: 15px 0; border-left: 5px solid; }
        .fourwh-item.what { border-color: #ff6b6b; }
        .fourwh-item.why { border-color: #ffd93d; }
        .fourwh-item.when { border-color: #4ecdc4; }
        .fourwh-item.where { border-color: #a855f7; }
        .fourwh-item.how { border-color: #64ffda; }
        .fourwh-item h4 { margin-bottom: 12px; font-size: 1.2em; }
        .fourwh-item.what h4 { color: #ff6b6b; }
        .fourwh-item.why h4 { color: #ffd93d; }
        .fourwh-item.when h4 { color: #4ecdc4; }
        .fourwh-item.where h4 { color: #a855f7; }
        .fourwh-item.how h4 { color: #64ffda; }
        .fourwh-item p, .fourwh-item li { color: #ccc; line-height: 1.7; }
        .prereq-box { background: linear-gradient(135deg, rgba(168,85,247,0.1), rgba(168,85,247,0.05)); border: 2px solid rgba(168,85,247,0.3); border-radius: 16px; padding: 25px; margin: 20px 0; }
        .prereq-box h3 { color: #a855f7; margin-bottom: 15px; }
        .prereq-item { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 15px; margin: 12px 0; border-left: 4px solid #a855f7; }
        .prereq-item h4 { color: #c084fc; margin-bottom: 8px; }
        .matrix-derivation { background: rgba(255,215,0,0.08); border: 2px solid rgba(255,215,0,0.3); border-radius: 16px; padding: 25px; margin: 25px 0; }
        .matrix-derivation h3 { color: #ffd93d; margin-bottom: 20px; }
        .derivation-step { background: rgba(0,0,0,0.3); border-radius: 10px; padding: 20px; margin: 15px 0; }
        .derivation-step h4 { color: #4ecdc4; margin-bottom: 12px; }
        .derivation-step .explanation { color: #ccc; line-height: 1.6; }
        .derivation-step .formula { background: rgba(100,255,218,0.1); padding: 15px; border-radius: 8px; margin: 10px 0; font-family: monospace; font-size: 1.1em; color: #64ffda; text-align: center; }
        .key-insight { background: linear-gradient(135deg, rgba(255,107,107,0.1), rgba(255,107,107,0.05)); border: 2px solid rgba(255,107,107,0.3); border-radius: 12px; padding: 20px; margin: 20px 0; }
        .key-insight h4 { color: #ff6b6b; margin-bottom: 10px; }
        .key-insight p { color: #ccc; line-height: 1.6; }
        .bloch-container { display: flex; gap: 30px; justify-content: center; flex-wrap: wrap; margin: 20px 0; }
        .bloch-main { background: rgba(0,0,0,0.5); border-radius: 16px; padding: 20px; }
        .bloch-canvas { width: 350px; height: 350px; border-radius: 12px; background: #050505; }
        .interactive-controls { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; margin: 20px 0; }
        .ctrl-btn { padding: 12px 24px; border: none; border-radius: 10px; font-size: 15px; cursor: pointer; font-weight: bold; transition: all 0.3s; }
        .ctrl-btn:hover { transform: scale(1.05); }
        .btn-u { background: linear-gradient(135deg, #64ffda, #4ecdc4); color: #000; }
        .btn-udag { background: linear-gradient(135deg, #ff6b6b, #ff8e8e); color: #fff; }
        .btn-reset { background: linear-gradient(135deg, #666, #888); color: #fff; }
        .history-display { background: rgba(0,0,0,0.4); border-radius: 12px; padding: 20px; min-width: 250px; }
        .history-display h4 { color: #64ffda; margin-bottom: 15px; }
        .history-item { padding: 8px 12px; margin: 5px 0; background: rgba(100,255,218,0.1); border-radius: 6px; font-family: monospace; color: #ccc; }
        .comparison-table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        .comparison-table th, .comparison-table td { padding: 15px; text-align: left; border: 1px solid rgba(100,255,218,0.3); }
        .comparison-table th { background: rgba(100,255,218,0.2); color: #64ffda; }
        .comparison-table td { background: rgba(0,0,0,0.3); color: #ccc; }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Unitary Operations & Reversibility</h1>
            <p class="subtitle">Why Quantum Gates Must Be Reversible</p>
        </header>

        <section class="section">
            <div class="prereq-box">
                <h3>Prerequisites</h3>
                <div class="prereq-item">
                    <h4>1. What is a Unitary Matrix?</h4>
                    <p>A matrix U is unitary if U†U = UU† = I, where U† is the conjugate transpose. This means U⁻¹ = U†. Unitary matrices preserve the length of vectors: ||U|ψ⟩|| = |||ψ⟩||.</p>
                </div>
                <div class="prereq-item">
                    <h4>2. Conjugate Transpose (Dagger)</h4>
                    <p>U† is obtained by transposing U and taking complex conjugates. For real matrices, U† = Uᵀ. For example: if U = [[a,b],[c,d]], then U† = [[a*,c*],[b*,d*]].</p>
                </div>
                <div class="prereq-item">
                    <h4>3. Probability Conservation</h4>
                    <p>Quantum states must have total probability 1: |α|² + |β|² = 1. Unitary operations preserve this normalization. Non-unitary operations would create or destroy probability!</p>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="fourwh-box">
                <h3>Unitarity - The 4W+H Framework</h3>
                
                <div class="fourwh-item what">
                    <h4>WHAT is Unitarity?</h4>
                    <p>A quantum gate U is unitary if U†U = I. This means every gate has an inverse (U† = U⁻¹), and applying U then U† returns to the original state. Unitarity is the mathematical requirement for reversibility.</p>
                </div>
                
                <div class="fourwh-item why">
                    <h4>WHY must quantum gates be unitary?</h4>
                    <p>Three fundamental reasons: (1) Probability conservation - total probability must stay 1. (2) Reversibility - quantum mechanics is time-reversible at the fundamental level. (3) Information preservation - no information is lost (until measurement).</p>
                </div>
                
                <div class="fourwh-item when">
                    <h4>WHEN is unitarity violated?</h4>
                    <p>Measurement is the only non-unitary operation in quantum computing! Measurement collapses the state irreversibly. Decoherence (interaction with environment) also causes non-unitary evolution. All gates between measurements must be unitary.</p>
                </div>
                
                <div class="fourwh-item where">
                    <h4>WHERE does unitarity appear?</h4>
                    <p>Every quantum gate matrix must satisfy U†U = I. Circuit simulators verify unitarity. Quantum error correction relies on unitarity to reverse errors. The Schrödinger equation guarantees unitary time evolution.</p>
                </div>
                
                <div class="fourwh-item how">
                    <h4>HOW to verify unitarity?</h4>
                    <p>Compute U†U and check if it equals I. For 2×2: check that columns are orthonormal (⟨col_i|col_j⟩ = δᵢⱼ). Equivalently, check |det(U)| = 1 and U†U = I.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Interactive Reversibility Demo</h2>
            <p>Apply gates and then their inverses. Watch the state return to the original!</p>
            
            <div class="bloch-container">
                <div class="bloch-main">
                    <div id="bloch-container" class="bloch-canvas"></div>
                    <div class="interactive-controls">
                        <button class="ctrl-btn btn-u" onclick="applyGate('X')">X</button>
                        <button class="ctrl-btn btn-udag" onclick="applyGate('X†')">X†</button>
                        <button class="ctrl-btn btn-u" onclick="applyGate('H')">H</button>
                        <button class="ctrl-btn btn-udag" onclick="applyGate('H†')">H†</button>
                        <button class="ctrl-btn btn-u" onclick="applyGate('S')">S</button>
                        <button class="ctrl-btn btn-udag" onclick="applyGate('S†')">S†</button>
                        <button class="ctrl-btn btn-u" onclick="applyGate('T')">T</button>
                        <button class="ctrl-btn btn-udag" onclick="applyGate('T†')">T†</button>
                        <button class="ctrl-btn btn-reset" onclick="resetState()">Reset</button>
                    </div>
                </div>
                <div class="history-display">
                    <h4>Gate History</h4>
                    <div id="history-list"></div>
                    <p style="color:#888;font-size:0.85em;margin-top:15px;">Apply U then U† to return to original state!</p>
                    <div style="margin-top:15px;padding:15px;background:rgba(100,255,218,0.1);border-radius:8px;">
                        <p style="color:#64ffda;margin:0;font-size:0.9em;"><strong>Current State:</strong></p>
                        <p style="color:#fff;font-family:monospace;margin:5px 0 0 0;" id="current-state">|0⟩</p>
                    </div>
                </div>
            </div>
        </section>

        <section class="section">
            <div class="matrix-derivation">
                <h3>Verifying Unitarity: Examples</h3>
                
                <div class="derivation-step">
                    <h4>Example 1: X Gate</h4>
                    <p class="explanation">X = [[0,1],[1,0]]. Since X is real and symmetric, X† = X.</p>
                    <div class="formula">X†X = [[0,1],[1,0]][[0,1],[1,0]] = [[1,0],[0,1]] = I ✓</div>
                    <p class="explanation">X is unitary AND self-inverse (X = X† = X⁻¹).</p>
                </div>
                
                <div class="derivation-step">
                    <h4>Example 2: Hadamard Gate</h4>
                    <p class="explanation">H = (1/√2)[[1,1],[1,-1]]. H is real and symmetric, so H† = H.</p>
                    <div class="formula">H†H = (1/2)[[1,1],[1,-1]][[1,1],[1,-1]] = (1/2)[[2,0],[0,2]] = I ✓</div>
                    <p class="explanation">H is also self-inverse (Hermitian and unitary).</p>
                </div>
                
                <div class="derivation-step">
                    <h4>Example 3: S Gate</h4>
                    <p class="explanation">S = [[1,0],[0,i]]. S† = [[1,0],[0,-i]] (conjugate of i is -i).</p>
                    <div class="formula">S†S = [[1,0],[0,-i]][[1,0],[0,i]] = [[1,0],[0,1]] = I ✓</div>
                    <p class="explanation">S is unitary but NOT self-inverse. S† = S⁻¹ ≠ S.</p>
                </div>
            </div>
        </section>

        <section class="section">
            <h3>Classical vs Quantum: Reversibility Comparison</h3>
            <table class="comparison-table">
                <tr>
                    <th>Property</th>
                    <th>Classical Gates</th>
                    <th>Quantum Gates</th>
                </tr>
                <tr>
                    <td>Reversibility</td>
                    <td>Most are irreversible (AND, OR lose info)</td>
                    <td>ALL gates are reversible (unitary)</td>
                </tr>
                <tr>
                    <td>Information</td>
                    <td>Can be destroyed (e.g., AND: 2 bits → 1 bit)</td>
                    <td>Always preserved (until measurement)</td>
                </tr>
                <tr>
                    <td>Energy</td>
                    <td>Irreversible ops dissipate heat (Landauer)</td>
                    <td>Reversible ops can be thermodynamically free</td>
                </tr>
                <tr>
                    <td>Inverse</td>
                    <td>Often doesn't exist</td>
                    <td>Always exists: U⁻¹ = U†</td>
                </tr>
            </table>
        </section>

        <section class="section">
            <div class="key-insight">
                <h4>Key Insight: Measurement breaks unitarity</h4>
                <p>Measurement is the ONLY non-unitary operation in quantum computing. When you measure, the state collapses irreversibly. You cannot "unmeasure" - the information about the original superposition is lost. This is why quantum algorithms carefully control when measurements happen.</p>
            </div>
        </section>

        <section class="section">
            <div class="matrix-derivation">
                <h3>Self-Inverse Gates (Hermitian Unitaries)</h3>
                <div class="derivation-step">
                    <h4>Gates where U = U† = U⁻¹</h4>
                    <p class="explanation">These gates are their own inverse - apply twice to return to original:</p>
                    <div class="formula">X² = Y² = Z² = H² = CNOT² = SWAP² = I</div>
                    <p class="explanation">These are both Hermitian (U = U†) and unitary (U†U = I).</p>
                </div>
                <div class="derivation-step">
                    <h4>Gates where U ≠ U†</h4>
                    <p class="explanation">Phase gates need their conjugate to reverse:</p>
                    <div class="formula">S·S† = T·T† = Rz(θ)·Rz(-θ) = I</div>
                    <p class="explanation">S† rotates -90° (undoing S's +90°). T† rotates -45°.</p>
                </div>
            </div>
        </section>

        <div class="nav-buttons">
            <a href="../09-swap-toffoli-gates/index.html" class="btn">Previous: SWAP & Toffoli</a>
            <a href="../11-universal-gate-sets/index.html" class="btn btn-primary">Next: Universal Gate Sets</a>
        </div>
    </div>

    <script>
    let scene, camera, renderer, controls, stateArrow;
    let theta = 0, phi = 0;
    let history = [];
    
    function init() {
        const container = document.getElementById('bloch-container');
        if (!container) return;
        
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050505);
        
        camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 100);
        camera.position.set(3, 2.5, 3);
        
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        container.appendChild(renderer.domElement);
        
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        
        const sphereGeo = new THREE.SphereGeometry(1, 32, 32);
        const sphereMat = new THREE.MeshBasicMaterial({ color: 0x64ffda, transparent: true, opacity: 0.1, wireframe: true });
        scene.add(new THREE.Mesh(sphereGeo, sphereMat));
        
        createAxis(new THREE.Vector3(1, 0, 0), 0xff6b6b, 'X');
        createAxis(new THREE.Vector3(0, 1, 0), 0x4ecdc4, 'Y');
        createAxis(new THREE.Vector3(0, 0, 1), 0xffd93d, 'Z');
        
        stateArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, 0), 1.1, 0x64ffda, 0.15, 0.1);
        scene.add(stateArrow);
        
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        animate();
        updateDisplay();
    }
    
    function createAxis(dir, color, label) {
        scene.add(new THREE.ArrowHelper(dir, new THREE.Vector3(0,0,0), 1.4, color, 0.08, 0.05));
        scene.add(new THREE.ArrowHelper(dir.clone().negate(), new THREE.Vector3(0,0,0), 1.4, color, 0.08, 0.05));
    }
    
    function updateDisplay() {
        var x = Math.sin(theta) * Math.cos(phi);
        var y = Math.sin(theta) * Math.sin(phi);
        var z = Math.cos(theta);
        stateArrow.setDirection(new THREE.Vector3(x, y, z).normalize());
        
        var name = '';
        if (theta < 0.1) name = '|0⟩';
        else if (Math.abs(theta - Math.PI) < 0.1) name = '|1⟩';
        else if (Math.abs(theta - Math.PI/2) < 0.1) {
            var pn = ((phi % (2*Math.PI)) + 2*Math.PI) % (2*Math.PI);
            if (pn < 0.1 || pn > 2*Math.PI - 0.1) name = '|+⟩';
            else if (Math.abs(pn - Math.PI) < 0.1) name = '|-⟩';
            else if (Math.abs(pn - Math.PI/2) < 0.1) name = '|i⟩';
            else if (Math.abs(pn - 3*Math.PI/2) < 0.1) name = '|-i⟩';
            else name = 'superposition';
        } else name = 'superposition';
        document.getElementById('current-state').textContent = name;
        
        var histHtml = '';
        history.slice(-8).forEach(function(g) {
            histHtml += '<div class="history-item">' + g + '</div>';
        });
        document.getElementById('history-list').innerHTML = histHtml || '<div class="history-item" style="color:#666;">No gates applied</div>';
    }
    
    function applyGate(g) {
        history.push(g);
        if (g === 'X' || g === 'X†') { theta = Math.PI - theta; phi = -phi; }
        else if (g === 'H' || g === 'H†') { var x = Math.sin(theta) * Math.cos(phi); var z = Math.cos(theta); theta = Math.acos(x); phi = (z >= 0) ? 0 : Math.PI; }
        else if (g === 'S') { phi = phi + Math.PI/2; }
        else if (g === 'S†') { phi = phi - Math.PI/2; }
        else if (g === 'T') { phi = phi + Math.PI/4; }
        else if (g === 'T†') { phi = phi - Math.PI/4; }
        updateDisplay();
    }
    
    function resetState() { theta = 0; phi = 0; history = []; updateDisplay(); }
    
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }
    
    window.addEventListener('load', init);
    </script>
</body>
</html>
